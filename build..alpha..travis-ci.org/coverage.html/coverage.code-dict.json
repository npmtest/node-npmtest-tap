{"/home/travis/build/npmtest/node-npmtest-tap/test.js":"/* istanbul instrument in package npmtest_tap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tap/lib.npmtest_tap.js":"/* istanbul instrument in package npmtest_tap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_tap = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_tap = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-tap/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-tap && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_tap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_tap\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught.stack);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_tap.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        local.assetsDict['/assets.npmtest_tap.rollup.js'] =\n            local.assetsDict['/assets.npmtest_tap.rollup.js'] ||\n            local.fs.readFileSync(\n                // buildCustomOrg-hack\n                local.npmtest_tap.__dirname +\n                    '/lib.npmtest_tap.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/tap.js":"var Test = require('./test.js')\nvar Stdin = require('./stdin.js')\nvar Spawn = require('./spawn.js')\nvar util = require('util')\nvar objToYaml = require('./obj-to-yaml.js')\nvar yaml = require('js-yaml')\n\nutil.inherits(TAP, Test)\nfunction TAP (options) {\n  Test.call(this, options)\n  this.start = Date.now()\n}\n\nvar didPipe = false\nTAP.prototype.pipe = function () {\n  didPipe = true\n  this.setTimeout(this.options.timeout)\n  this.pipe = Test.prototype.pipe\n  this.push = Test.prototype.push\n  var ret = this.pipe.apply(this, arguments)\n  this.process()\n  return ret\n}\n\nfunction monkeypatchEpipe () {\n  process.stdout.emit = function (emit) {\n    return function (ev, er) {\n      if (ev === 'error' && er.code === 'EPIPE')\n        return this.emit = emit\n      return emit.apply(this, arguments)\n    }\n  }(process.stdout.emit)\n}\n\nfunction monkeypatchExit () {\n  // ensure that we always get run, even if a user does\n  // process.on('exit', process.exit)\n  process.reallyExit = function (original) {\n    return function reallyExit (code) {\n      code = onExitEvent(code)\n      return original.call(this, code)\n    }\n  }(process.reallyExit)\n\n  process.exit = function (original) {\n    return function exit (code) {\n      code = onExitEvent(code)\n      return original.call(this, code)\n    }\n  }(process.exit)\n\n  process.on('exit', onExitEvent)\n}\n\nvar didOnExitEvent = false\nfunction onExitEvent (code) {\n  if (didOnExitEvent)\n    return process.exitCode || code\n\n  didOnExitEvent = true\n\n  if (!tap.results)\n    tap.endAll()\n\n  if (tap.results && !tap.results.ok && code === 0) {\n    process.exitCode = 1\n    if (process.version.match(/^v0\\.(10|[0-9])\\./))\n      process.exit(code)\n  }\n\n  return process.exitCode || code || 0\n}\n\nTAP.prototype.push = function push () {\n  // this resets push and pipe to standard values\n  this.pipe(process.stdout)\n  this.patchProcess()\n  return this.push.apply(this, arguments)\n}\n\nTAP.prototype.patchProcess = function () {\n  monkeypatchEpipe()\n  monkeypatchExit()\n  process.on('uncaughtException', this.threw)\n  process.on('unhandledRejection', function (er) {\n    this.threw(er)\n  }.bind(this))\n}\n\nTAP.prototype.onbail = function () {\n  Test.prototype.onbail.apply(this, arguments)\n  this.endAll()\n  process.exit(1)\n}\n\nTAP.prototype.onbeforeend = function () {\n  if (didPipe && this.time && !this.bailedOut)\n    this.emit('data', '# time=' + this.time + 'ms\\n')\n}\n\nTAP.prototype.ondone = function () {\n  try {\n    this.emit('teardown')\n  } catch (er) {\n    this.threw(er)\n  }\n}\n\n// Root test runner doesn't have the 'teardown' event, because it\n// isn't hooked into any parent Test as a harness.\nTAP.prototype.teardown = TAP.prototype.tearDown = function (fn) {\n  this.autoend()\n  return Test.prototype.teardown.apply(this, arguments)\n}\n\nvar opt = { name: 'TAP' }\nif (process.env.TAP_DEBUG === '1' ||\n    /\\btap\\b/.test(process.env.NODE_DEBUG || ''))\n  opt.debug = true\n\nvar tap = new TAP(opt)\nmodule.exports = tap\ntap.mocha = require('./mocha.js')\ntap.mochaGlobals = tap.mocha.global\n\ntap.Test = Test\ntap.Spawn = Spawn\ntap.Stdin = Stdin\ntap.synonyms = require('./synonyms.js')\n\n// SIGTERM means being forcibly killed, almost always by timeout\nvar onExit = require('signal-exit')\nvar didTimeoutKill = false\nonExit(function (code, signal) {\n  if (signal !== 'SIGTERM' || !didPipe || didTimeoutKill)\n    return\n\n  var handles = process._getActiveHandles().filter(function (h) {\n    return h !== process.stdout &&\n    h !== process.stdin &&\n    h !== process.stderr\n  })\n  var requests = process._getActiveRequests()\n\n  // Ignore this because it's really hard to test cover in a way\n  // that isn't inconsistent and unpredictable.\n  /* istanbul ignore next */\n  var extra = {\n    at: null,\n    signal: signal\n  }\n  if (requests.length) {\n    extra.requests = requests.map(function (r) {\n      var ret = { type: r.constructor.name }\n      if (r.context) {\n        ret.context = r.context\n      }\n      return ret\n    })\n  }\n  if (handles.length) {\n    extra.handles = handles.map(function (h) {\n      var ret = { type: h.constructor.name }\n      if (h.msecs) {\n        ret.msecs = h.msecs\n      }\n      if (h._events) {\n        ret.events = Object.keys(h._events)\n      }\n      if (h._sockname) {\n        ret.sockname = h._sockname\n      }\n      if (h._connectionKey) {\n        ret.connectionKey = h._connectionKey\n      }\n      return ret\n    })\n  }\n\n  // this is impossible to cover, because it happens after nyc has\n  // already done its stuff.\n  /* istanbul ignore else */\n  if (!tap.results && tap.timeout)\n    tap.timeout(extra)\n  else {\n    console.error('possible timeout: SIGTERM received after tap end')\n    if (extra.handles || extra.requests) {\n      delete extra.signal\n      if (!extra.at) {\n        delete extra.at\n      }\n      var yaml = require('js-yaml')\n      console.error(objToYaml(extra))\n    }\n    didTimeoutKill = true\n    process.kill(process.pid, 'SIGTERM')\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/test.js":"// We need TWO queues (work and subtest) and one jobs pool\n//\n// The pool stores buffered subtests being run in parallel.\n//\n// When new subtests are created, they get put in the work queue and also\n// in the subtests queue if they are buffered and jobs>0.  When we put a\n// test in the subtest queue, we also process it.\n//\n// Processing the subtest queue means moving tests into the jobs pool until\n// the jobs pool length is at this.jobs\n//\n// Any output functions get put in the work queue if its length > 0 (ie,\n// no cutting the line)\n//\n// Processing the work queue means walking until we run out of things, or\n// encounter an unfinished test.  When we encounter ANY kind of test, we\n// block until its output is completed, dumping it all into the parser.\n\nvar Base = require('./base.js')\nvar Spawn = require('./spawn.js')\nvar Stdin = require('./stdin.js')\nvar Deferred = require('trivial-deferred')\nvar Pool = require('yapool')\nvar TestPoint = require('./point.js')\nvar parseTestArgs = require('./parse-test-args.js')\nvar loop = require('function-loop')\n\nvar extraFromError = require('./extra-from-error.js')\nvar stack = require('./stack.js')\nvar assert = require('assert')\nvar util = require('util')\nutil.inherits(Test, Base)\nvar ownOr = require('own-or')\nvar ownOrEnv = require('own-or-env')\nvar tapAsserts = require('./asserts.js')\nvar Promise = require('bluebird')\nvar bindObj = require('bind-obj-methods')\n\n// A sigil object for implicit end() calls that should not\n// trigger an error if the user then calls t.end()\nvar IMPLICIT = {}\n\n// Sigil to put in the queue to signal the end of all things\nvar EOF = { EOF: true }\n\nfunction hasOwn (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nmodule.exports = Test\n\nfunction Test (options) {\n  options = options || {}\n  if (!(this instanceof Test))\n    return new Test(options)\n\n  Base.call(this, options)\n  this.pushedEnd = false\n  this.jobs = ownOr(options, 'jobs', 1)\n  this.subtests = []\n  this.pool = new Pool()\n  this.queue = ['TAP version 13\\n']\n  this.noparallel = false\n  this.cb = this.domain.bind(options.cb)\n  this.occupied = false\n  this.currentAssert = null\n  this.count = 0\n  this.n = 0\n  this.ended = false\n  this.explicitEnded = false\n  this.multiEndThrew = false\n  this.currentAssert = null\n  this.assertAt = null\n  this.assertStack = null\n  this.planEnd = -1\n  this.onBeforeEach = []\n  this.onAfterEach = []\n  this.ranAfterEach = false\n\n  // bind all methods to this object, so we can pass t.end as a callback\n  // and do `var test = require('tap').test` like people do.\n  var bound = Object.create(null)\n  bindObj(this, this, bound)\n  bindObj(this, Object.getPrototypeOf(this), bound)\n  bindObj(this, Test.prototype, bound)\n}\n\nTest.prototype.current = function () {\n  throw new Error('Test.current() as been removed and is no more')\n}\n\nTest.prototype.spawn = function spawn (cmd, args, options, name) {\n  if (typeof args === 'string') {\n    args = [ args ]\n  }\n\n  args = args || []\n\n  if (typeof options === 'string') {\n    name = options\n    options = {}\n  }\n\n  options = options || {}\n  options.name = ownOr(options, 'name', name)\n  options.command = cmd\n  options.args = args\n\n  return this.sub(Spawn, options, spawn)\n}\n\nTest.prototype.sub = function (Class, extra, caller) {\n  if (extra && (extra.todo || extra.skip)) {\n    this.pass(extra.name, extra)\n    return Promise.resolve(this)\n  }\n\n  extra.indent = '    '\n  if (this.jobs > 1 && process.env.TAP_BUFFER === undefined)\n    extra.buffered = ownOr(extra, 'buffered', true)\n  else\n    extra.buffered = ownOrEnv(extra, 'buffered', 'TAP_BUFFER', true)\n\n  extra.bail = ownOr(extra, 'bail', this.bail)\n  extra.parent = this\n  extra.stack = stack.captureString(80, caller)\n  var t = new Class(extra)\n\n  this.queue.push(t)\n  this.subtests.push(t)\n\n  var d = new Deferred()\n  t.deferred = d\n  this.process()\n  return d.promise\n}\n\nTest.prototype.test = function test (name, extra, cb) {\n  extra = parseTestArgs(name, extra, cb)\n  return this.sub(Test, extra, test)\n}\n\nTest.prototype.stdin = function stdin (name, extra) {\n  extra = parseTestArgs(name, extra, function () {}, '/dev/stdin')\n  return this.sub(Stdin, extra || {}, stdin)\n}\n\nTest.prototype.bailout = function (message) {\n  if (this.parent && (this.results || this.ended))\n    this.parent.bailout(message)\n  else {\n    this.process()\n    message = message ? ' ' + ('' + message).trim() : ''\n    message = message.replace(/[\\r\\n]/g, ' ')\n    this.parser.write('Bail out!' + message + '\\n')\n  }\n  this.end(IMPLICIT)\n  this.process()\n}\n\nTest.prototype.comment = function () {\n  var message = util.format.apply(util, arguments)\n  message = '# ' + message.split(/\\r?\\n/).join('\\n# ') + '\\n'\n\n  if (this.results)\n    this.push(message)\n  else\n    this.queue.push(message)\n  this.process()\n}\n\nTest.prototype.timeout = function (options) {\n  options = options || {}\n  options.expired = options.expired || this.name\n  if (this.occupied)\n    this.occupied.timeout(options)\n  else\n    Base.prototype.timeout.call(this, options)\n  this.end(IMPLICIT)\n}\n\nTest.prototype.main = function (cb) {\n  this.setTimeout(this.options.timeout)\n  this.debug('MAIN pre', this)\n\n  var self = this\n  try {\n    var ret = this.cb(this)\n  } catch (er) {\n    this.threw(er)\n  }\n\n  if (ret && ret.then) {\n    this.promise = ret\n    ret.tapAbortPromise = done\n    ret.then(end, done)\n  } else\n    done()\n\n  function end () {\n    self.debug(' > implicit end for promise')\n    self.end(IMPLICIT)\n    done()\n  }\n\n  function done (er) {\n    if (er)\n      self.threw(er)\n\n    if (self.results || self.bailedOut)\n      cb()\n    else\n      self.ondone = cb\n  }\n\n  this.debug('MAIN post', this)\n}\n\nTest.prototype.process = function () {\n  if (this.processing)\n    return this.debug(' < already processing')\n\n  this.debug('\\nPROCESSING(%s)', this.name, this.queue.length)\n  this.processing = true\n\n  var p\n\n  while (!this.occupied && (p = this.queue.shift())) {\n    this.debug('PROCESS(%s)', this.name, p)\n    if (p instanceof Base) {\n      this.processSubtest(p)\n    } else if (p === EOF) {\n      this.debug(' > EOF', this.name)\n      // I AM BECOME EOF, DESTROYER OF STREAMS\n      this.parser.end()\n    } else if (p instanceof TestPoint) {\n      this.debug(' > TESTPOINT')\n      this.parser.write(p.ok + (++this.n) + p.message)\n    } else if (typeof p === 'string') {\n      this.debug(' > STRING')\n      this.parser.write(p)\n    } else if (Array.isArray(p)) {\n      this.debug(' > METHOD')\n      var m = p.shift()\n      this[m].apply(this, p)\n    } else {\n      throw new Error('weird thing got in the queue')\n    }\n  }\n\n  while (!this.noparallel &&\n         this.pool.length < this.jobs &&\n         (p = this.subtests.shift())) {\n    if (!p.buffered) {\n      this.noparallel = true\n      break\n    }\n    this.debug('start subtest', p)\n    this.pool.add(p)\n    if (this.bailedOut)\n      this.onbufferedend(p)\n    else\n      this.runBeforeEach(p,\n        p.main.bind(p,\n          this.onbufferedend.bind(this, p)))\n  }\n\n  this.debug('done processing', this.queue, this.occupied)\n  this.processing = false\n\n  // just in case any tests ended, and we have sync stuff still\n  // waiting around in the queue to be processed\n  if (!this.occupied && this.queue.length)\n    this.process()\n\n  this.maybeAutoend()\n}\n\nTest.prototype.processSubtest = function (p) {\n  this.debug(' > subtest')\n  this.occupied = p\n  if (!p.buffered) {\n    if (this.bailedOut)\n      return this.onindentedend(p)\n    this.debug(' > subtest indented')\n    p.pipe(this.parser, { end: false })\n    this.runBeforeEach(p,\n      this.writeSubComment.bind(this, p,\n        p.main.bind(p,\n          this.onindentedend.bind(this, p))))\n  } else if (p.readyToProcess) {\n    this.debug(' > subtest buffered, finished')\n    // finished!  do the thing!\n    this.occupied = null\n    if (!p.passing() || !p.silent) {\n      this.queue.unshift(['emitSubTeardown', p])\n      this.printResult(p.passing(), p.name, p.options, true)\n    }\n  } else {\n    this.occupied = p\n    this.debug(' > subtest buffered, unfinished', p)\n    // unfinished buffered test.\n    // nothing to do yet, just leave it there.\n    this.queue.unshift(p)\n  }\n}\n\nTest.prototype.emitSubTeardown = function (p) {\n  try {\n    p.emit('teardown')\n  } catch (er) {\n    delete p.options.time\n    p.threw(er)\n  }\n}\n\nTest.prototype.writeSubComment = function (p, cb) {\n  var comment = '# Subtest'\n  if (p.name)\n    comment += ': ' + p.name\n  comment += '\\n'\n  this.parser.write(comment)\n  cb()\n}\n\nTest.prototype.onbufferedend = function (p, er) {\n  delete p.ondone\n  p.results = p.results || {}\n  p.readyToProcess = true\n  var to = p.options.timeout\n  if (to && p.passing())\n    var dur = Date.now() - p.start\n  if (dur && dur > to)\n    p.timeout()\n  else\n    p.setTimeout(false)\n  this.debug('%s.onbufferedend', this.name, p.name, p.results.bailout)\n  this.pool.remove(p)\n  p.options.tapChildBuffer = p.output || ''\n  p.options.stack = ''\n  if (p.time)\n    p.options.time = p.time\n  if (this.occupied === p)\n    this.occupied = null\n  if (er)\n    this.threw(er)\n  p.deferred.resolve(this)\n  this.process()\n}\n\nTest.prototype.onindentedend = function (p, er) {\n  delete p.ondone\n  this.debug('onindentedend', p)\n  this.noparallel = false\n  var sti = this.subtests.indexOf(p)\n  if (sti !== -1)\n    this.subtests.splice(sti, 1)\n  p.readyToProcess = true\n  p.results = p.results || {}\n  if (p.time)\n    p.options.time = p.time\n  var to = p.options.timeout\n  if (to && p.passing())\n    var dur = Date.now() - p.start\n  if (dur && dur > to)\n    p.timeout()\n  else\n    p.setTimeout(false)\n  this.debug('onindentedend %s(%s)', this.name, p.name, er || 'ok')\n  assert(this.occupied === p)\n  this.occupied = null\n  this.debug('OIE(%s) b>shift into queue', this.name, this.queue)\n  p.options.stack = ''\n\n  this.queue.unshift(['emitSubTeardown', p])\n  this.printResult(p.passing(), p.name, p.options, true)\n\n  this.debug('OIE(%s) shifted into queue', this.name, this.queue)\n  if (er)\n    this.threw(er)\n  p.deferred.resolve(this)\n  this.process()\n}\n\nTest.prototype.addAssert = function (name, length, fn) {\n  if (!name)\n    throw new TypeError('name is required for addAssert')\n\n  if (!(typeof length === 'number' && length >= 0))\n    throw new TypeError('number of args required')\n\n  if (typeof fn !== 'function')\n    throw new TypeError('function required for addAssert')\n\n  if (Test.prototype[name] || this[name])\n    throw new TypeError('attempt to re-define `' + name + '` assert')\n\n  this[name] = function ASSERT () {\n    if (!this.currentAssert) {\n      this.currentAssert = ASSERT\n    }\n    var args = new Array(length + 2)\n    for (var i = 0; i < length; i++) {\n      args[i] = arguments[i]\n    }\n    if (typeof arguments[length] === 'object') {\n      args[length] = ''\n      args[length + 1] = arguments[length]\n    } else {\n      args[length] = arguments[length] || ''\n      args[length + 1] = arguments[length + 1] || {}\n    }\n\n    return fn.apply(this, args)\n  }\n}\n\nTest.prototype.fail = function fail (message, extra) {\n  if (!this.currentAssert) {\n    this.currentAssert = fail\n  }\n\n  if (message && typeof message === 'object') {\n    extra = message\n    message = ''\n  } else {\n    if (!message) {\n      message = ''\n    }\n    if (!extra) {\n      extra = {}\n    }\n  }\n\n  this.printResult(false, message, extra)\n\n  var ret = true\n  if (!extra.todo && !extra.skip)\n    ret = false\n\n  return ret\n}\n\nTest.prototype.pass = function pass (message, extra) {\n  if (!this.currentAssert) {\n    this.currentAssert = pass\n  }\n  this.printResult(true, message || '(unnamed test)', extra)\n  return true\n}\n\nTest.prototype.printResult = function pR (ok, message, extra, front) {\n  var n = this.count + 1\n  if (this.planEnd !== -1 && n > this.planEnd) {\n    if (!this.passing())\n      return\n\n    var failMessage = this.explicitEnded\n        ? 'test after end() was called'\n        : 'test count exceeds plan'\n\n    var er = new Error(failMessage)\n    Error.captureStackTrace(er, this.currentAssert || pR)\n    er.test = this.name\n    er.plan = this.planEnd\n    this.threw(er)\n    return\n  }\n\n  extra = extra || {}\n\n  if (this.assertAt) {\n    extra.at = this.assertAt\n    this.assertAt = null\n  }\n\n  if (this.assertStack) {\n    extra.stack = this.assertStack\n    this.assertStack = null\n  }\n\n  if (hasOwn(extra, 'stack') && !hasOwn(extra, 'at'))\n    extra.at = stack.parseLine(extra.stack.split('\\n')[0])\n\n  var fn = this.currentAssert || pR\n  this.currentAssert = null\n  if (!ok && !extra.skip && !hasOwn(extra, 'at')) {\n    assert.equal(typeof fn, 'function')\n    extra.at = stack.at(fn)\n    if (!extra.todo)\n      extra.stack = stack.captureString(80, fn)\n  }\n\n  var diagnostic\n  if (!ok)\n    diagnostic = true\n\n  if (extra.skip)\n    diagnostic = false\n\n  if (process.env.TAP_DIAG === '0')\n    diagnostic = false\n\n  if (typeof extra.diagnostic === 'boolean')\n    diagnostic = extra.diagnostic\n\n  if (diagnostic)\n    extra.diagnostic = true\n\n  this.count = n\n  var res = { ok: ok, message: message, extra: extra }\n  var output = new TestPoint(ok, message, extra)\n  // when we jump the queue, skip an extra line\n  if (front)\n    output.message = output.message.trimRight() + '\\n\\n'\n\n  if (front) {\n    this.emit('result', res)\n    this.parser.write(output.ok + (++this.n) + output.message)\n  } else\n    this.queue.push(['emit', 'result', res], output)\n\n  if (this.planEnd === this.count)\n    this.end(IMPLICIT)\n\n  this.process()\n}\n\nTest.prototype.pragma = function (set) {\n  var p = ''\n  Object.keys(set).forEach(function (i) {\n    p += 'pragma ' + (set[i] ? '+' : '-') + i + '\\n'\n  })\n  this.queue.push(p)\n  this.process()\n}\n\nTest.prototype.plan = function (n, comment) {\n  if (this.bailedOut)\n    return\n\n  if (this.planEnd !== -1) {\n    throw new Error('Cannot set plan more than once')\n  }\n\n  if (typeof n !== 'number' || n < 0) {\n    throw new TypeError('plan must be a number')\n  }\n\n  // Cannot get any tests after a trailing plan, or a plan of 0\n  var ending = false\n  if (this.count !== 0 || n === 0) {\n    ending = true\n  }\n\n  if (n === 0)\n    this.skip = comment || true\n\n  this.planEnd = n\n  comment = comment ? ' # ' + comment.trim() : ''\n  this.queue.push('1..' + n + comment + '\\n')\n\n  if (ending)\n    this.end(IMPLICIT)\n  else\n    this.process()\n}\n\nTest.prototype.done = Test.prototype.end = function (implicit) {\n  this.debug('END implicit=%j', implicit === IMPLICIT)\n  if (this.ended && implicit === IMPLICIT)\n    return\n\n  // beyond here we have to be actually done with things, or else\n  // the semantic checks on counts and such will be off.\n  if (!queueEmpty(this) || this.occupied) {\n    if (!this.pushedEnd)\n      this.queue.push(['end', implicit])\n    this.pushedEnd = true\n    return this.process()\n  }\n\n  if (!this.ranAfterEach && this.parent) {\n    this.ranAfterEach = true\n    this.parent.runAfterEach(this, end.bind(this, implicit))\n  } else\n    end.call(this, implicit)\n}\n\nfunction end (implicit) {\n  this.ended = true\n\n  if (implicit !== IMPLICIT && !this.multiEndThrew) {\n    if (this.explicitEnded) {\n      this.multiEndThrew = true\n      var er = new Error('test end() method called more than once')\n      Error.captureStackTrace(er, this.currentAssert || end)\n      er.test = this.name\n      this.threw(er)\n      return\n    }\n    this.explicitEnded = true\n  }\n\n  if (this.planEnd === -1) {\n    this.debug('END(%s) implicit plan', this.name, this.count)\n    this.plan(this.count)\n  }\n\n  this.queue.push(EOF)\n  this.process()\n}\n\nTest.prototype.threw = function (er, extra, proxy) {\n  this.debug('THREW', er.message, extra, proxy)\n\n  // event emitters 'error' events need to re-throw so that they\n  // can jump out of the flow like a normal throw.  They'll just\n  // end up back here once that happens, though, unless there's a\n  // try/catch somewhere in the call stack.\n  if (er.domainEmitter) {\n    delete er.domainEmitter\n    throw er\n  }\n\n  if (this.name && !proxy)\n    er.test = this.name\n  if (!proxy)\n    extra = extraFromError(er, extra, this.options)\n  Base.prototype.threw.call(this, er, extra, proxy)\n\n  if (!this.results) {\n    this.fail(extra.message || er.message, extra)\n    if (!proxy)\n      this.end(IMPLICIT)\n  }\n  this.process()\n}\n\nTest.prototype.runBeforeEach = function (who, cb) {\n  var self = this\n  if (this.parent)\n    this.parent.runBeforeEach(who, function () {\n      loop(who, self.onBeforeEach, cb, who.threw)\n    })\n  else\n    loop(who, self.onBeforeEach, cb, who.threw)\n}\n\nTest.prototype.runAfterEach = function (who, cb) {\n  var self = this\n  loop(who, self.onAfterEach, function () {\n    if (self.parent)\n      self.parent.runAfterEach(who, cb)\n    else\n      cb()\n  }, who.threw)\n}\n\nTest.prototype.beforeEach = function (fn) {\n  this.onBeforeEach.push(fn)\n}\n\nTest.prototype.afterEach = function (fn) {\n  this.onAfterEach.push(fn)\n}\n\nTest.prototype.teardown = Test.prototype.tearDown = function (fn) {\n  this.on('teardown', fn)\n}\n\nTest.prototype.shouldAutoend = function () {\n  var should = (\n    this.options.autoend &&\n    !this.ended &&\n    !this.occupied &&\n    queueEmpty(this) &&\n    !this.pool.length &&\n    !this.subtests.length &&\n    this.planEnd === -1\n  )\n  return should\n}\n\nTest.prototype.autoend = function () {\n  this.options.autoend = true\n  this.maybeAutoend()\n}\n\nTest.prototype.maybeAutoend = function () {\n  if (this.autoendTimer)\n    clearTimeout(this.autoendTimer)\n\n  if (this.shouldAutoend()) {\n    var self = this\n    self.autoendTimer = setTimeout(function () {\n      if (self.shouldAutoend()) {\n        self.autoendTimer = setTimeout(function () {\n          if (self.shouldAutoend()) {\n            self.end(IMPLICIT)\n          }\n        })\n      }\n    })\n  }\n}\n\nfunction endAllQueue (queue) {\n  queue.forEach(function (p, i) {\n    if ((p instanceof Base) && !p.readyToProcess)\n      queue[i] = new TestPoint(false,\n        'child test left in queue ' + p.constructor.name + ': ' +\n        p.name, p.options)\n  })\n  queue.push(['end', IMPLICIT])\n}\n\nfunction queueEmpty (t) {\n  return t.queue.length === 0 ||\n    t.queue.length === 1 && t.queue[0] === 'TAP version 13\\n'\n}\n\nTest.prototype.endAll = function (sub) {\n  this.processing = true\n  if (this.occupied) {\n    var p = this.occupied\n    if (p.endAll)\n      p.endAll(true)\n    else {\n      p.parser.abort('test unfinished')\n    }\n  } else if (sub) {\n    this.process()\n    if (queueEmpty(this)) {\n      var options = Object.keys(this.options).reduce(function (o, k) {\n        o[k] = this.options[k]\n        return o\n      }.bind(this), {})\n      this.options.at = null\n      this.options.stack = ''\n      options.test = this.name\n      this.fail('test unfinished', options)\n    }\n  }\n  if (this.promise && this.promise.tapAbortPromise)\n    this.promise.tapAbortPromise()\n  if (this.occupied) {\n    this.queue.unshift(this.occupied)\n    this.occupied = null\n  }\n  endAllQueue(this.queue)\n  this.processing = false\n  this.process()\n  this.parser.end()\n}\n\n// Add all the asserts\ntapAsserts.decorate(Test.prototype)\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/base.js":"module.exports = Base\n\nvar Readable = require('stream').Readable\n/* istanbul ignore if */\nif (!Readable || process.version.match(/^v0\\.10/)) {\n  Readable = require('readable-stream').Readable\n}\n\nvar extraFromError = require('./extra-from-error.js')\nvar assert = require('assert')\nvar cleanYamlObject = require('./clean-yaml-object.js')\n\nvar domain = require('domain')\nvar util = require('util')\nutil.inherits(Base, Readable)\n\nvar Parser = require('tap-parser')\n\nvar ownOr = require('own-or')\nvar ownOrEnv = require('own-or-env')\n\nfunction Base (options) {\n  this.start = 0\n  this.hrtime = null\n  this.time = null\n  this.readyToProcess = false\n  this.options = options\n  this.parent = ownOr(options, 'parent', null)\n  this.bail = ownOrEnv(options, 'bail', 'TAP_BAIL', true)\n  this.name = ownOr(options, 'name', '')\n  if (!this.name)\n    this.name = ''\n  else\n    this.name = this.name.replace(/[\\n\\r\\s\\t]/g, ' ')\n  this.indent = ownOr(options, 'indent', '')\n  this.silent = !!options.silent\n  this.buffered = !!options.buffered || !!options.silent\n  this.finished = false\n  this.strict = ownOrEnv(options, 'strict', 'TAP_STRICT', true)\n  this.omitVersion = !!options.omitVersion\n  this.preserveWhitespace = ownOr(options, 'preserveWhitespace', true)\n  this.jobs = +ownOrEnv(options, 'jobs', 'TAP_JOBS') || 0\n  this.skip = ownOr(options, 'skip', false)\n  this.todo = ownOr(options, 'todo', false)\n  this.setupParser(options)\n  this.finished = false\n  this.output = ''\n  this.results = null\n  this.bailedOut = false\n  if (this.skip || this.todo)\n    this.main = Base.prototype.main\n\n  Readable.apply(this, options)\n\n  domain.create().add(this)\n  this.domain.on('error', this.threw.bind(this))\n\n  if (typeof options.debug === 'boolean')\n    this.debug = options.debug ? debug : nodebug\n}\n\nBase.prototype.passing = function () {\n  return this.parser.ok\n}\n\nBase.prototype.setTimeout = function (n) {\n  if (!this.hrtime)\n    this.hrtime = process.hrtime()\n\n  if (!n) {\n    clearTimeout(this.timer)\n    this.timer = null\n  } else {\n    this.start = Date.now()\n    this.timer = setTimeout(this.timeout.bind(this), n)\n    if (this.timer.unref)\n      this.timer.unref()\n  }\n}\n\nBase.prototype.threw = function (er, extra, proxy) {\n  if (this.name && !proxy)\n    er.test = this.name\n\n  var message = er.message\n\n  if (!extra)\n    extra = extraFromError(er, extra, this.options)\n\n  if (this.results || this.ended) {\n    this.results.ok = false\n    if (this.parent)\n      this.parent.threw(er, extra, true)\n    else if (!er.stack)\n      console.error(er)\n    else {\n      er.message = message\n      delete extra.stack\n      delete extra.at\n      console.error('%s: %s', er.name || 'Error', message)\n      console.error(er.stack.split(/\\n/).slice(1).join('\\n'))\n      console.error(extra)\n    }\n  } else\n    this.parser.ok = false\n\n  return extra\n}\n\nBase.prototype.timeout = function (options) {\n  this.setTimeout(false)\n  var er = new Error('timeout!')\n  options = options || {}\n  options.expired = options.expired || this.name\n  this.threw(new Error('timeout!'), options)\n}\n\nBase.prototype.main = function (cb) {\n  cb()\n}\n\nBase.prototype.online = function (line) {\n  this.debug('LINE %j', line)\n  return this.push(this.indent + line)\n}\n\nBase.prototype.push = function (c, e) {\n  assert.equal(typeof c, 'string')\n  assert.equal(c.substr(-1), '\\n')\n\n  if (this.buffered) {\n    this.output += c\n    return true\n  }\n\n  // We *always* want data coming out immediately.  Test runners have a\n  // very special relationship with zalgo. It's more important to ensure\n  // that any console.log() lines that appear in the midst of tests are\n  // not taken out of context\n  if (this._readableState) {\n    this._readableState.sync = false\n  }\n\n  // this.debug(this._readableState)\n  return Readable.prototype.push.call(this, c, e)\n}\n\nBase.prototype.onbail = function (reason) {\n  this.bailedOut = reason || true\n  this.emit('bailout', reason)\n}\n\nBase.prototype.oncomplete = function (results) {\n  if (this.hrtime) {\n    this.hrtime = process.hrtime(this.hrtime)\n    this.time = Math.round(this.hrtime[0] * 1e6 + this.hrtime[1] / 1e3) / 1e3\n  }\n\n  this.debug('ONCOMPLETE %j %j', this.name, results)\n\n  if (this.results)\n    Object.keys(this.results).forEach(function (k) {\n      results[k] = this.results[k]\n    }, this)\n\n  this.results = results\n  this.emit('complete', results)\n  var failures = results.failures.filter(function (f) {\n    delete f.diag\n    delete f.ok\n    return f.tapError\n  })\n\n  if (failures.length)\n    this.options.failures = failures\n\n  this.onbeforeend()\n  this.emit('end')\n  this.ondone()\n}\n\nBase.prototype.onbeforeend = function () {}\nBase.prototype.ondone = function () {}\n\nBase.prototype.setupParser = function (options) {\n  this.parser = new Parser({\n    bail: this.bail,\n    strict: this.strict,\n    omitVersion: this.omitVersion,\n    preserveWhitespace: this.preserveWhitespace\n  })\n  assert(this.parser.preserveWhitespace)\n  this.parser.on('line', this.online.bind(this))\n  this.parser.once('bailout', this.onbail.bind(this))\n  this.parser.on('complete', this.oncomplete.bind(this))\n}\n\nBase.prototype._read = function (n) {\n  // this.emit('readable')\n  // this.debug('_read %j', this.name, arguments)\n}\n\nBase.prototype.inspect = function () {\n  return this.constructor.name + ' ' + util.inspect({\n    name: this.name,\n    jobs: this.jobs,\n    buffered: this.buffered,\n    occupied: this.occupied,\n    pool: this.pool,\n    queue: this.queue,\n    subtests: this.subtests,\n    output: this.output,\n    skip: this.skip,\n    todo: this.todo,\n    results: this.results,\n    options: [\n      'autoend',\n      'command',\n      'args',\n      'stdio',\n      'env',\n      'cwd',\n      'exitCode',\n      'signal',\n      'expired',\n      'timeout',\n      'at',\n      'skip',\n      'todo'\n    ].reduce(function (set, k) {\n      if (this.options[k] !== undefined)\n        set[k] = this.options[k]\n      return set\n    }.bind(this), {})\n  })\n}\n\nBase.prototype.debug = (/\\btap\\b/i.test(process.env.NODE_DEBUG || ''))\n  ? debug : nodebug\n\nfunction nodebug () {}\n\n/* istanbul ignore next */\nfunction debug () {\n  var prefix = 'TAP ' + process.pid + ' ' + this.name + ': '\n  var msg = util.format.apply(util, arguments).trim()\n  msg = prefix + msg.split('\\n').join('\\n' + prefix)\n  console.error(msg)\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/extra-from-error.js":"var stack = require('./stack.js')\n\nmodule.exports = function (er, extra, options) {\n  extra = Object.keys(options || {}).reduce(function (set, k) {\n    if (!(k in set) && !/^tapChild/.test(k))\n      set[k] = options[k]\n    return set\n  }, extra || {})\n\n  if (!er || typeof er !== 'object') {\n    extra.error = er\n    return extra\n  }\n\n  var message = er.message\n  var addName = true\n\n  if (!message && er.stack) {\n    message = er.stack.split('\\n')[0]\n    addName = false\n  }\n\n  er.message = ''\n  var st = er.stack\n  if (st) {\n    st = st.split('\\n')\n    // parse out the 'at' bit from the first line.\n    extra.at = stack.parseLine(st[1])\n    extra.stack = stack.clean(st)\n  }\n  er.message = message\n\n  if (er.name && er.name !== 'Error')\n    extra.type = er.name\n\n  Object.keys(er).forEach(function (k) {\n    if (k === 'message' ||\n        k === 'domainEmitter' ||\n        k === 'domainThrown' ||\n        k === 'domain' ||\n        k === 'domainBound')\n      return\n    extra[k] = er[k]\n  })\n\n  return extra\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/stack.js":"var sourceMapSupport = require('source-map-support')\nvar StackUtils = require('stack-utils')\nvar path = require('path')\nvar tapDir = path.resolve(__dirname, '..')\n\n// don't skip when developing on tap itself\nvar skip = process.cwd() !== tapDir ||\n  +process.env.TAP_DEV_SHORTSTACK === 1 &&\n  +process.env.TAP_DEV_LONGSTACK !== 1\n? [\n    /node_modules[\\/\\\\]tap[\\/\\\\]/,\n    new RegExp(resc(tapDir) + '\\\\b', 'i'),\n    new RegExp(resc(require.resolve('function-loop'))),\n    new RegExp(resc(path.dirname(require.resolve('bluebird/package.json'))))\n  ]\n: []\n\nsourceMapSupport.install({environment:'node'})\n// Ignore tap if it's a dependency, or anything\n// in this lib folder.\nmodule.exports = new StackUtils({\n  internals: StackUtils.nodeInternals().concat(skip),\n  wrapCallSite: sourceMapSupport.wrapCallSite\n})\n\nfunction resc(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/clean-yaml-object.js":"var cleanYamlObject = require('clean-yaml-object')\nvar path = require('path')\nvar Module = require('module')\nvar fs = require('fs')\nvar binpath = path.resolve(__dirname, '../bin')\nvar stack = require('./stack.js')\nvar Domain = require('domain').Domain\n\nfunction hasOwn (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nmodule.exports = cleanTapYamlObject\n\nfunction cleanTapYamlObject (object) {\n  if (hasOwn(object, 'stack') && !hasOwn(object, 'at'))\n    object.at = stack.parseLine(object.stack.split('\\n')[0])\n\n  var file = object.at && object.at.file && path.resolve(object.at.file)\n  if (file && (file.indexOf(__dirname) === 0 || file.indexOf(binpath) === 0))\n    delete object.at\n\n  if (object.at && object.at.file && object.at.line && !object.source) {\n    var content\n    file = path.resolve(object.at.file)\n    try {\n      content = Module.wrap(fs.readFileSync(file))\n    } catch (er) {}\n    if (content) {\n      content = (content.split('\\n')[object.at.line - 1] || '').trim()\n      if (content)\n        object.source = content + '\\n'\n    }\n  }\n\n  return cleanYamlObject(object, yamlFilter)\n}\n\nfunction yamlFilter (propertyName, isRoot, source, target) {\n  if (source instanceof Domain)\n    return false\n\n  if (!isRoot)\n    return true\n\n  if (propertyName === 'stack') {\n    if (source.stack)\n      target.stack = source.stack\n    return false\n  }\n\n  return !(propertyName === 'todo' ||\n  propertyName === 'time' ||\n  /^_?tapChild/.test(propertyName) ||\n  /^tapStream/.test(propertyName) ||\n  /^tapMochaTest/.test(propertyName) ||\n  propertyName === 'cb' ||\n  propertyName === 'name' ||\n  propertyName === 'indent' ||\n  propertyName === 'skip' ||\n  propertyName === 'bail' ||\n  propertyName === 'diagnostic' ||\n  propertyName === 'buffered' ||\n  propertyName === 'parent' ||\n  propertyName === 'domainEmitter' ||\n  propertyName === 'domainThrew' ||\n  propertyName === 'domain' ||\n  (propertyName === 'at' && !source.at))\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/spawn.js":"var Base = require('./base.js')\n\nvar assert = require('assert')\nvar util = require('util')\nutil.inherits(Spawn, Base)\nvar ownOr = require('own-or')\nvar path = require('path')\nvar cleanYamlObject = require('./clean-yaml-object.js')\n\nmodule.exports = Spawn\n\nvar cp = require('child_process')\nvar spawn = cp.spawn\n\nfunction Spawn (options) {\n  options = options || {}\n  if (!(this instanceof Spawn))\n    return new Spawn(options)\n\n  Base.call(this, options)\n\n  this.command = options.command\n\n  if (!this.command)\n    throw new TypeError('no command provided')\n\n  this.args = options.args\n  // stdout must be a pipe\n  if (options.stdio) {\n    if (typeof options.stdio === 'string')\n      this.stdio = [ options.stdio, 'pipe', options.stdio ]\n    else\n      this.stdio = options.stdio.slice(0)\n  } else\n    this.stdio = [ 0, 'pipe', 2 ]\n\n  this.stdio[1] = 'pipe'\n  var env = options.env || process.env\n  this.env = Object.keys(env).reduce(function (e, k) {\n    e[k] = env[k]\n    return e\n  }, {})\n\n  this.env.TAP = '1'\n  if (this.bail)\n    this.env.TAP_BAIL = '1'\n\n  this.cwd = ownOr(options, 'cwd', process.cwd())\n  options.cwd = this.cwd\n  if (!this.name) {\n    if (this.command === process.execPath) {\n      this.name = path.basename(process.execPath) + ' ' +\n        this.args.map(function (a) {\n          if (a.indexOf(this.cwd) === 0) {\n            return './' +\n              a.substr(this.cwd.length + 1).replace(/\\\\/g, '/')\n          } else {\n            return a\n          }\n        }, this).join(' ')\n    } else {\n      this.name = this.command + ' ' + this.args.join(' ')\n    }\n  }\n\n  this.proc = null\n}\n\nSpawn.prototype.endAll = function () {\n  if (this.proc)\n    this.proc.kill('SIGKILL')\n  this.parser.abort('test unfinished')\n  this.cb()\n}\n\nSpawn.prototype.main = function (cb) {\n  this.cb = cb\n  this.setTimeout(this.options.timeout)\n  var options = Object.keys(this.options).reduce(function (o, k) {\n    o[k] = this.options[k]\n    return o\n  }.bind(this), {\n    cwd: this.cwd,\n    env: this.env,\n    stdio: this.stdio\n  })\n  try {\n    var proc = this.proc = spawn(this.command, this.args, options)\n    proc.stdout.pipe(this.parser)\n    proc.on('close', this.onprocclose.bind(this))\n    proc.on('error', this.threw.bind(this))\n  } catch (er) {\n    this.threw(er)\n  }\n}\n\nSpawn.prototype.threw = function (er, extra, proxy) {\n  extra = Base.prototype.threw.call(this, er, extra, proxy)\n  extra = cleanYamlObject(extra)\n  // unhook entirely\n  this.parser.abort(er.message, extra)\n  if (this.proc) {\n    this.proc.stdout.removeAllListeners('data')\n    this.proc.stdout.removeAllListeners('end')\n    this.proc.removeAllListeners('close')\n    this.proc.kill('SIGKILL')\n  }\n  this.cb()\n}\n\nSpawn.prototype.onprocclose = function (code, signal) {\n  this.debug('SPAWN close %j %s', code, signal)\n  this.options.exitCode = code\n  if (signal)\n    this.options.signal = signal\n  this.results = this.results || {}\n\n  // spawn closing with no tests is treated as a skip.\n  if (this.results.plan && this.results.plan.skipAll && !code && !signal)\n    this.options.skip = this.results.plan.skipReason || true\n\n  if (code || signal) {\n    this.results.ok = false\n    this.parser.ok = false\n  }\n  return this.cb()\n}\n\nSpawn.prototype.timeout = function (extra) {\n  if (this.proc)\n    this.proc.kill('SIGTERM')\n  var t = setTimeout(function () {\n    if (!this.options.signal && this.options.exitCode === undefined) {\n      Base.prototype.timeout.call(this, extra)\n      this.proc.kill('SIGKILL')\n    }\n  }.bind(this), 1000)\n  if (t.unref)\n    t.unref()\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/stdin.js":"var Base = require('./base.js')\nvar util = require('util')\nvar ownOr = require('own-or')\nvar domain = require('domain')\n\nutil.inherits(Stdin, Base)\n\nmodule.exports = Stdin\n\nfunction Stdin (options) {\n  options = options || {}\n  if (!(this instanceof Stdin))\n    return new Stdin(options)\n\n  options.name = ownOr(options, 'name', '/dev/stdin')\n  Base.call(this, options)\n\n  // This has to be here for node 0.10's wonky streams\n  this.stream = ownOr(options, 'tapStream', process.stdin)\n  this.stream.pause()\n}\n\nStdin.prototype.main = function (cb) {\n  this.domain.add(this.stream)\n  this.setTimeout(this.options.timeout)\n  this.stream.pipe(this.parser)\n  this.stream.resume()\n  this.once('end', cb)\n}\n\nStdin.prototype.threw = function (er, extra, proxy) {\n  extra = Base.prototype.threw.call(this, er, extra, proxy)\n  this.options = extra\n  this.parser.abort(er.message, extra)\n  this.parser.end()\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/point.js":"module.exports = TestPoint\n\nvar path = require('path')\nvar binpath = path.resolve(__dirname, '../bin')\nvar util = require('util')\nvar diags = require('./diags.js')\n\nfunction TestPoint (ok, message, extra) {\n  if (typeof ok !== 'boolean')\n    throw new TypeError('ok must be boolean')\n\n  if (!(this instanceof TestPoint))\n    return new TestPoint(ok, message, extra)\n\n  this.ok = ok ? 'ok ' : 'not ok '\n  this.message = tpMessage(message, extra)\n}\n\nfunction tpMessage (message, extra) {\n  message = message + ''\n  if (message)\n    message = ' - ' + message\n  message = message.replace(/[\\n\\r]/g, ' ').replace(/\\t/g, '  ')\n  extra = extra || {}\n\n  if (extra.skip) {\n    message += ' # SKIP'\n    if (typeof extra.skip === 'string')\n      message += ' ' + extra.skip\n  } else if (extra.todo) {\n    message += ' # TODO'\n    if (typeof extra.todo === 'string')\n      message += ' ' + extra.todo\n  } else if (extra.time)\n    message += ' # time=' + extra.time + 'ms'\n\n  var diagYaml = extra.diagnostic ? diags(extra) : ''\n  message += diagYaml\n\n  if (extra.tapChildBuffer || extra.tapChildBuffer === '') {\n    if (!diagYaml)\n      message += ' '\n    message += '{\\n' + extra.tapChildBuffer.trimRight() + '\\n}\\n'\n  }\n\n  message += '\\n'\n  return message\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/diags.js":"module.exports = diags\n\nvar objToYaml = require('./obj-to-yaml.js')\n\nfunction diags (extra) {\n  var y = objToYaml(extra)\n  if (y)\n    y = '\\n' + y\n\n  return y\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/obj-to-yaml.js":"module.exports = objToYaml\n\nvar cleanYamlObject = require('./clean-yaml-object.js')\nvar yaml = require('js-yaml')\n\nfunction objToYaml (obj) {\n  obj = cleanYamlObject(obj)\n  var y = ''\n  if (obj && typeof obj === 'object' && Object.keys(obj).length) {\n    y = yaml.safeDump(obj).split('\\n').map(function (l) {\n      return l.trim() ? '  ' + l : l.trim()\n    }).join('\\n')\n    y = '  ---\\n' + y + '  ...\\n'\n  }\n\n  return y\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/parse-test-args.js":"function typeOf (arg) {\n  var t = typeof arg\n  switch (t) {\n    case 'object':\n      return arg ? 'object' : 'null'\n    default:\n      return t\n  }\n}\n\nmodule.exports = function (name_, extra_, cb_, defaultName) {\n  var name\n  var extra\n  var cb\n\n  // this only works if it's literally the 4th argument.  it's mostly\n  // used internally.\n  defaultName = defaultName || '(unnamed test)'\n\n  for (var i = 0; i < 3 && i < arguments.length; i++) {\n    var arg = arguments[i]\n    var type = typeOf(arg)\n    if (name === undefined && (type === 'string' || type === 'number'))\n      name = '' + arg\n    else if (type === 'object') {\n      extra = arg\n      if (name === undefined)\n        name = null\n    } else if (type === 'function') {\n      if (extra === undefined)\n        extra = {}\n      if (name === undefined)\n        name = null\n      cb = arg\n    } else if (arg === false) {\n      // it's handy while developing to put a ! in front of a\n      // function to temporarily make a test TODO\n      continue\n    } else if (type !== 'undefined')\n      throw new TypeError('unknown argument passed to parseTestArgs: ' + type)\n  }\n\n  if (!extra)\n    extra = {}\n\n  if (!cb)\n    extra.todo = true\n\n  if (!name && extra.name)\n    name = extra.name\n\n  if (!name && cb && cb.name)\n    name = cb.name\n\n  name = name || defaultName\n  extra.name = name\n  extra.cb = cb || todoCb\n  return extra\n}\n\n/* istanbul ignore next */\nfunction todoCb () {\n  throw new Error('callback called for TODO test')\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/asserts.js":"var synonyms = require('./synonyms.js')\nvar deeper = require('deeper') // strict\nvar shallower = require('only-shallow') // in touch with its feelings\nvar tmatch = require('tmatch') // ok with partial estimates\nvar extraFromError = require('./extra-from-error.js')\n\n// Load Buffer the old way for browserify's sake\nvar Buffer = require('buffer').Buffer // eslint-disable-line\n\n// this is actually the \"working half\" of the Test class.\n// each method figures out if it's a pass or fail, and decorates\n// the extra bit, and then calls either pass() or fail() or some\n// other assert method.\n//\n// typically, a plugin would do this on a specific instance, eg on\n// the root test harness instance.  but we do this here to add some\n// useful prototype methods.\n\nexports.decorate = decorate\n\nfunction decorate (t) {\n  t.addAssert('ok', 1, function (obj, message, extra) {\n    message = message || 'expect truthy value'\n    if (obj) {\n      return this.pass(message, extra)\n    }\n\n    return this.fail(message, extra)\n  })\n\n  t.addAssert('notOk', 1, function (obj, message, extra) {\n    message = message || 'expect falsey value'\n    return this.ok(!obj, message, extra)\n  })\n\n  t.addAssert('error', 1, function (er, message, extra) {\n    if (!er) {\n      return this.pass(message || 'should not error', extra)\n    }\n\n    if (!(er instanceof Error)) {\n      extra.found = er\n      return this.fail(message || 'non-Error error encountered', extra)\n    }\n\n    message = message || er.message\n    extra.found = er\n    return this.fail(message, extra)\n  })\n\n  t.addAssert('equal', 2, function (f, w, m, e) {\n    m = m || 'should be equal'\n    if (f === w) {\n      return this.pass(m, e)\n    }\n\n    e.found = f\n    e.wanted = w\n    e.compare = '==='\n\n    if (typeof f === 'object' &&\n        typeof w === 'object' &&\n        f &&\n        w &&\n        shallower(f, w)) {\n      e.note = 'Objects never === one another'\n    }\n\n    return this.fail(m, e)\n  })\n\n  t.addAssert('not', 2, function (f, w, m, e) {\n    m = m || 'should not be equal'\n    if (f !== w) {\n      return this.pass(m, e)\n    }\n\n    e.found = f\n    e.doNotWant = w\n    e.compare = '!=='\n\n    return this.fail(m, e)\n  })\n\n  t.addAssert('same', 2, function (f, w, m, e) {\n    m = m || 'should be equivalent'\n    e.found = f\n    e.wanted = w\n    return this.ok(shallower(f, w), m, e)\n  })\n\n  t.addAssert('notSame', 2, function (f, w, m, e) {\n    m = m || 'should not be equivalent'\n    e.found = f\n    e.doNotWant = w\n    return this.notOk(shallower(f, w), m, e)\n  })\n\n  t.addAssert('strictSame', 2, function (f, w, m, e) {\n    m = m || 'should be equivalent strictly'\n    e.found = f\n    e.wanted = w\n    return this.ok(deeper(f, w), m, e)\n  })\n\n  t.addAssert('strictNotSame', 2, function (f, w, m, e) {\n    m = m || 'should be equivalent strictly'\n    e.found = f\n    e.doNotWant = w\n    return this.notOk(deeper(f, w), m, e)\n  })\n\n  t.addAssert('match', 2, function (f, w, m, e) {\n    m = m || 'should match pattern provided'\n    e.found = f\n    e.pattern = w\n    return this.ok(tmatch(f, w), m, e)\n  })\n\n  t.addAssert('notMatch', 2, function (f, w, m, e) {\n    m = m || 'should not match pattern provided'\n    e.found = f\n    e.pattern = w\n    return this.ok(!tmatch(f, w), m, e)\n  })\n\n  t.addAssert('type', 2, function (obj, klass, m, e) {\n    var name = klass\n    if (typeof name === 'function') {\n      name = name.name || '(anonymous constructor)'\n    }\n    m = m || 'type is ' + name\n\n    // simplest case, it literally is the same thing\n    if (obj === klass) {\n      return this.pass(m, e)\n    }\n\n    var type = typeof obj\n    if (!obj && type === 'object') {\n      type = 'null'\n    }\n\n    if (type === 'object' && klass !== 'object') {\n      if (typeof klass === 'function') {\n        e.found = Object.getPrototypeOf(obj).constructor.name\n        e.wanted = name\n        return this.ok(obj instanceof klass, m, e)\n      }\n\n      // check prototype chain for name\n      // at this point, we already know klass is not a function\n      // if the klass specified is an obj in the proto chain, pass\n      // if the name specified is the name of a ctor in the chain, pass\n      var p = obj\n      do {\n        var ctor = p.constructor && p.constructor.name\n        if (p === klass || ctor === name) {\n          return this.pass(m, e)\n        }\n        p = Object.getPrototypeOf(p)\n      } while (p)\n    }\n\n    return this.equal(type, name, m, e)\n  })\n\n  t.addAssert('throws', 4, function (fn_, wanted_, m_, e_, m, e__) {\n    var fn, wanted, e\n    for (var i = 0; i < arguments.length - 1; i++) {\n      var arg = arguments[i]\n      if (typeof arg === 'function') {\n        if (arg === Error || arg.prototype instanceof Error) {\n          wanted = arg\n        } else if (!fn) {\n          fn = arg\n        }\n      } else if (typeof arg === 'string' && arg) {\n        m = arg\n      } else if (typeof arg === 'object') {\n        if (!wanted) {\n          wanted = arg\n        } else {\n          e = arg\n        }\n      }\n    }\n\n    // Copy local properties of the 'extra' object, like 'skip' etc\n    Object.keys(e__).forEach(function (i) {\n      e[i] = e__[i]\n    })\n\n    if (!m) {\n      m = fn && fn.name || 'expected to throw'\n    }\n\n    if (wanted) {\n      if (wanted instanceof Error) {\n        var w = {\n          message: wanted.message\n        }\n        if (wanted.name) {\n          w.name = wanted.name\n        }\n\n        // intentionally copying non-local properties, since this\n        // is an Error object, and those are funky.\n        for (i in wanted) {\n          w[i] = wanted[i]\n        }\n        wanted = w\n\n        m += ': ' + (wanted.name || 'Error') + ' ' + wanted.message\n        e = e || {}\n        if (e !== wanted) {\n          e.wanted = wanted\n        }\n      }\n    }\n\n    if (typeof fn !== 'function') {\n      e = e || {}\n      e.todo = true\n      return this.pass(m, e)\n    }\n\n    try {\n      fn()\n      return this.fail(m, e)\n    } catch (er) {\n      // 'name' is a getter.\n      if (er.name) {\n        er.name = er.name + ''\n      }\n\n      if (wanted) {\n        if (Object.prototype.toString.call(wanted) === '[object RegExp]') {\n          return this.match(er.message, wanted, m, e)\n        }\n        return this.has(er, wanted, m, e)\n      } else {\n        return this.pass(m, e)\n      }\n    }\n  })\n\n  t.addAssert('doesNotThrow', 1, function (fn, m, e) {\n    if (typeof fn === 'string') {\n      var x = fn\n      fn = m\n      m = x\n    }\n\n    if (!m) {\n      m = fn && fn.name || 'expected to not throw'\n    }\n\n    if (typeof fn !== 'function') {\n      e.todo = true\n      return this.pass(m, e)\n    }\n\n    try {\n      fn()\n      return this.pass(m, e)\n    } catch (er) {\n      return this.fail(m, extraFromError(er, e))\n    }\n  })\n\n  // synonyms are helpful.\n  Object.keys(synonyms).forEach(function (c) {\n    if (t[c]) {\n      synonyms[c].forEach(function (s) {\n        Object.defineProperty(t, s, {\n          value: t[c],\n          enumerable: false,\n          configurable: true,\n          writable: true\n        })\n      })\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/synonyms.js":"// A list of all the synonyms of assert methods.\n// In addition to these, multi-word camelCase are also synonymized to\n// all lowercase and snake_case\nmodule.exports = multiword({\n  ok: ['true', 'assert'],\n  notOk: ['false', 'assertNot'],\n\n  error: ['ifError', 'ifErr'],\n  throws: ['throw'],\n  doesNotThrow: ['notThrow'],\n\n  // exactly the same.  ===\n  equal: [\n    'equals', 'isEqual', 'is', 'strictEqual', 'strictEquals', 'strictIs',\n    'isStrict', 'isStrictly'\n  ],\n\n  // not equal.  !==\n  not: [\n    'inequal', 'notEqual', 'notEquals', 'notStrictEqual', 'notStrictEquals',\n    'isNotEqual', 'isNot', 'doesNotEqual', 'isInequal'\n  ],\n\n  // deep equivalence.  == for scalars\n  same: [\n    'equivalent', 'looseEqual', 'looseEquals', 'deepEqual',\n    'deepEquals', 'isLoose', 'looseIs', 'isEquivalent'\n  ],\n\n  // deep inequivalence. != for scalars\n  notSame: [\n    'inequivalent', 'looseInequal', 'notDeep', 'deepInequal',\n    'notLoose', 'looseNot', 'notEquivalent', 'isNotDeepEqual',\n    'isNotDeeply', 'notDeepEqual', 'isInequivalent',\n    'isNotEquivalent'\n  ],\n\n  // deep equivalence, === for scalars\n  strictSame: [\n    'strictEquivalent', 'strictDeepEqual', 'sameStrict', 'deepIs',\n    'isDeeply', 'isDeep', 'strictDeepEquals'\n  ],\n\n  // deep inequivalence, !== for scalars\n  strictNotSame: [\n    'strictInequivalent', 'strictDeepInequal', 'notSameStrict', 'deepNot',\n    'notDeeply', 'strictDeepInequals', 'notStrictSame'\n  ],\n\n  // found has the fields in wanted, string matches regexp\n  match: [\n    'has', 'hasFields', 'matches', 'similar', 'like', 'isLike',\n    'includes', 'include', 'isSimilar', 'contains'\n  ],\n\n  notMatch: [\n    'dissimilar', 'unsimilar', 'notSimilar', 'unlike', 'isUnlike',\n    'notLike', 'isNotLike', 'doesNotHave', 'isNotSimilar', 'isDissimilar'\n  ],\n\n  type: [\n    'isa', 'isA'\n  ]\n})\n\nfunction multiword (obj) {\n  Object.keys(obj).forEach(function (i) {\n    var list = obj[i]\n    var res = [ multiword_(i) ].concat(list.map(multiword_))\n    res = res.reduce(function (set, i) {\n      set.push.apply(set, i)\n      return set\n    }, [])\n    obj[i] = res\n  })\n  return obj\n}\n\nfunction multiword_ (str) {\n  var res = [ str ]\n  if (str.match(/[A-Z]/)) {\n    res.push(str.toLowerCase())\n    res.push(str.replace(/[A-Z]/g, function ($0) {\n      return '_' + $0.toLowerCase()\n    }))\n  }\n  return res\n}\n","/home/travis/build/npmtest/node-npmtest-tap/tap/lib/mocha.js":"exports.it = exports.specify = it\nexports.context = exports.describe = describe\nexports.before = before\nexports.after = after\nexports.beforeEach = beforeEach\nexports.afterEach = afterEach\n\nexports.global = function () {\n  Object.keys(exports).forEach(function (g) {\n    global[g] = exports[g]\n  })\n}\n\nvar t = require('./tap.js')\nt.jobs = 1\nvar tapStack = [ t ]\nvar level = 0\nvar suiteStack = []\n\nfunction describe (name, fn) {\n  new Suite(name, fn)\n}\n\nfunction Suite (name, fn) {\n  this.parent = suiteStack[ suiteStack.length - 1 ]\n  if (typeof name === 'function')\n    fn = name, name = null\n  if (fn && fn.name && !name)\n    name = fn.name\n  this.todo = !fn\n  this.fn = fn\n  this.name = name\n  this.after = []\n  this.test = null\n\n  this.run()\n}\n\nSuite.prototype.run = function () {\n  var t = tapStack[ tapStack.length - 1 ]\n  t.test(this.name, { todo: this.todo }, function (tt) {\n    this.test = tt\n    tapStack.push(tt)\n    suiteStack.push(this)\n    var ret = this.fn()\n    this.runAfter()\n    suiteStack.pop()\n    return ret\n  }.bind(this))\n}\n\nSuite.prototype.runAfter = function () {\n  this.after.forEach(function (namefn) {\n    var name = namefn[0]\n    var fn = namefn[1]\n    before(name, fn)\n  })\n  do {\n    var t = tapStack.pop()\n  } while (t && t !== this.test)\n  if (this.test && !this.test.results)\n    t.end()\n}\n\nfunction before (name, fn) {\n  if (typeof name === 'function')\n    fn = name, name = null\n  if (fn && fn.name && !name)\n    name = fn.name\n  var todo = !fn\n  var suite = suiteStack[ suiteStack.length - 1 ]\n  var t = tapStack[ tapStack.length - 1 ]\n  if (!name)\n    name = ''\n  t.test(name, { todo: todo, silent: true }, function (tt) {\n    var ret = fn.call(suite, done(tt))\n    if (!ret && fn.length === 0)\n      tt.end()\n    else\n      return ret\n  })\n\n  function done (tt) { return function (er) {\n    if (er)\n      tt.threw(er)\n    else\n      tt.end()\n  }}\n}\n\nfunction it (name, fn) {\n  if (typeof name === 'function')\n    fn = name, name = null\n  if (fn && fn.name && !name)\n    name = fn.name\n  var todo = !fn\n  var suite = suiteStack[ suiteStack.length - 1 ]\n  var t = tapStack[ tapStack.length - 1 ]\n  if (!name)\n    name = ''\n  t.test(name, { todo: todo, tapMochaTest: true }, function (tt) {\n    var ret = fn.call(tt, done(tt))\n    if (ret && ret.then)\n      return ret\n    else if (fn.length === 0)\n      tt.end()\n  })\n\n  function done (tt) { return function (er) {\n    if (er)\n      tt.threw(er)\n    else\n      tt.end()\n  }}\n}\n\nfunction after (name, fn) {\n  var suite = suiteStack[ suiteStack.length - 1 ]\n  if (!suite)\n    throw new Error('cannot call \"after\" outside of describe()')\n  if (fn)\n    suite.after.push([name, fn])\n  else\n    suite.after.push([name])\n}\n\nfunction moment (when, fn) {\n  var t = tapStack[ tapStack.length - 1 ]\n  t[when](function (cb) {\n    if (!this.options.tapMochaTest)\n      return cb()\n    var suite = suiteStack[ suiteStack.length - 1 ]\n    var ret = fn.call(this, cb)\n    if (ret && ret.then)\n      return ret\n    else if (fn.length === 0)\n      return cb()\n  })\n}\n\nfunction beforeEach (fn) {\n  moment('beforeEach', fn)\n}\n\nfunction afterEach (fn) {\n  moment('afterEach', fn)\n}\n"}