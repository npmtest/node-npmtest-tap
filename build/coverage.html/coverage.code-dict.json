{"/home/travis/build/npmtest/node-npmtest-tap/test.js":"/* istanbul instrument in package npmtest_tap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tap/lib.npmtest_tap.js":"/* istanbul instrument in package npmtest_tap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_tap = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_tap = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-tap/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-tap && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_tap */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_tap\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_tap.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_tap.rollup.js'] =\n            local.assetsDict['/assets.npmtest_tap.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_tap.__dirname + '/lib.npmtest_tap.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/tap.js":"var Test = require('./test.js')\nvar Stdin = require('./stdin.js')\nvar Spawn = require('./spawn.js')\nvar util = require('util')\nvar objToYaml = require('./obj-to-yaml.js')\nvar yaml = require('js-yaml')\n\nutil.inherits(TAP, Test)\nfunction TAP (options) {\n  Test.call(this, options)\n  this.start = Date.now()\n}\n\nvar didPipe = false\nTAP.prototype.pipe = function () {\n  didPipe = true\n  this.setTimeout(this.options.timeout)\n  this.pipe = Test.prototype.pipe\n  this.push = Test.prototype.push\n  var ret = this.pipe.apply(this, arguments)\n  this.process()\n  return ret\n}\n\nfunction monkeypatchEpipe () {\n  process.stdout.emit = function (emit) {\n    return function (ev, er) {\n      if (ev === 'error' && er.code === 'EPIPE')\n        return this.emit = emit\n      return emit.apply(this, arguments)\n    }\n  }(process.stdout.emit)\n}\n\nfunction monkeypatchExit () {\n  // ensure that we always get run, even if a user does\n  // process.on('exit', process.exit)\n  process.reallyExit = function (original) {\n    return function reallyExit (code) {\n      code = onExitEvent(code)\n      return original.call(this, code)\n    }\n  }(process.reallyExit)\n\n  process.exit = function (original) {\n    return function exit (code) {\n      code = onExitEvent(code)\n      return original.call(this, code)\n    }\n  }(process.exit)\n\n  process.on('exit', onExitEvent)\n}\n\nvar didOnExitEvent = false\nfunction onExitEvent (code) {\n  if (didOnExitEvent)\n    return process.exitCode || code\n\n  didOnExitEvent = true\n\n  if (!tap.results)\n    tap.endAll()\n\n  if (tap.results && !tap.results.ok && code === 0) {\n    process.exitCode = 1\n    if (process.version.match(/^v0\\.(10|[0-9])\\./))\n      process.exit(code)\n  }\n\n  return process.exitCode || code || 0\n}\n\nTAP.prototype.push = function push () {\n  // this resets push and pipe to standard values\n  this.pipe(process.stdout)\n  this.patchProcess()\n  return this.push.apply(this, arguments)\n}\n\nTAP.prototype.patchProcess = function () {\n  monkeypatchEpipe()\n  monkeypatchExit()\n  process.on('uncaughtException', this.threw)\n  process.on('unhandledRejection', function (er) {\n    this.threw(er)\n  }.bind(this))\n}\n\nTAP.prototype.onbail = function () {\n  Test.prototype.onbail.apply(this, arguments)\n  this.endAll()\n  process.exit(1)\n}\n\nTAP.prototype.onbeforeend = function () {\n  if (didPipe && this.time && !this.bailedOut)\n    this.emit('data', '# time=' + this.time + 'ms\\n')\n}\n\nTAP.prototype.ondone = function () {\n  try {\n    this.emit('teardown')\n  } catch (er) {\n    this.threw(er)\n  }\n}\n\n// Root test runner doesn't have the 'teardown' event, because it\n// isn't hooked into any parent Test as a harness.\nTAP.prototype.teardown = TAP.prototype.tearDown = function (fn) {\n  this.autoend()\n  return Test.prototype.teardown.apply(this, arguments)\n}\n\nvar opt = { name: 'TAP' }\nif (process.env.TAP_DEBUG === '1' ||\n    /\\btap\\b/.test(process.env.NODE_DEBUG || ''))\n  opt.debug = true\n\nvar tap = new TAP(opt)\nmodule.exports = tap\ntap.mocha = require('./mocha.js')\ntap.mochaGlobals = tap.mocha.global\n\ntap.Test = Test\ntap.Spawn = Spawn\ntap.Stdin = Stdin\ntap.synonyms = require('./synonyms.js')\n\n// SIGTERM means being forcibly killed, almost always by timeout\nvar onExit = require('signal-exit')\nvar didTimeoutKill = false\nonExit(function (code, signal) {\n  if (signal !== 'SIGTERM' || !didPipe || didTimeoutKill)\n    return\n\n  var handles = process._getActiveHandles().filter(function (h) {\n    return h !== process.stdout &&\n    h !== process.stdin &&\n    h !== process.stderr\n  })\n  var requests = process._getActiveRequests()\n\n  // Ignore this because it's really hard to test cover in a way\n  // that isn't inconsistent and unpredictable.\n  /* istanbul ignore next */\n  var extra = {\n    at: null,\n    signal: signal\n  }\n  if (requests.length) {\n    extra.requests = requests.map(function (r) {\n      var ret = { type: r.constructor.name }\n      if (r.context) {\n        ret.context = r.context\n      }\n      return ret\n    })\n  }\n  if (handles.length) {\n    extra.handles = handles.map(function (h) {\n      var ret = { type: h.constructor.name }\n      if (h.msecs) {\n        ret.msecs = h.msecs\n      }\n      if (h._events) {\n        ret.events = Object.keys(h._events)\n      }\n      if (h._sockname) {\n        ret.sockname = h._sockname\n      }\n      if (h._connectionKey) {\n        ret.connectionKey = h._connectionKey\n      }\n      return ret\n    })\n  }\n\n  // this is impossible to cover, because it happens after nyc has\n  // already done its stuff.\n  /* istanbul ignore else */\n  if (!tap.results && tap.timeout)\n    tap.timeout(extra)\n  else {\n    console.error('possible timeout: SIGTERM received after tap end')\n    if (extra.handles || extra.requests) {\n      delete extra.signal\n      if (!extra.at) {\n        delete extra.at\n      }\n      var yaml = require('js-yaml')\n      console.error(objToYaml(extra))\n    }\n    didTimeoutKill = true\n    process.kill(process.pid, 'SIGTERM')\n  }\n})\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/test.js":"// We need TWO queues (work and subtest) and one jobs pool\n//\n// The pool stores buffered subtests being run in parallel.\n//\n// When new subtests are created, they get put in the work queue and also\n// in the subtests queue if they are buffered and jobs>0.  When we put a\n// test in the subtest queue, we also process it.\n//\n// Processing the subtest queue means moving tests into the jobs pool until\n// the jobs pool length is at this.jobs\n//\n// Any output functions get put in the work queue if its length > 0 (ie,\n// no cutting the line)\n//\n// Processing the work queue means walking until we run out of things, or\n// encounter an unfinished test.  When we encounter ANY kind of test, we\n// block until its output is completed, dumping it all into the parser.\n\nvar Base = require('./base.js')\nvar Spawn = require('./spawn.js')\nvar Stdin = require('./stdin.js')\nvar Deferred = require('trivial-deferred')\nvar Pool = require('yapool')\nvar TestPoint = require('./point.js')\nvar parseTestArgs = require('./parse-test-args.js')\nvar loop = require('function-loop')\n\nvar extraFromError = require('./extra-from-error.js')\nvar stack = require('./stack.js')\nvar assert = require('assert')\nvar util = require('util')\nutil.inherits(Test, Base)\nvar ownOr = require('own-or')\nvar ownOrEnv = require('own-or-env')\nvar tapAsserts = require('./asserts.js')\nvar Promise = require('bluebird')\nvar bindObj = require('bind-obj-methods')\n\n// A sigil object for implicit end() calls that should not\n// trigger an error if the user then calls t.end()\nvar IMPLICIT = {}\n\n// Sigil to put in the queue to signal the end of all things\nvar EOF = { EOF: true }\n\nfunction hasOwn (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nmodule.exports = Test\n\nfunction Test (options) {\n  options = options || {}\n  if (!(this instanceof Test))\n    return new Test(options)\n\n  Base.call(this, options)\n  this.pushedEnd = false\n  this.jobs = ownOr(options, 'jobs', 1)\n  this.subtests = []\n  this.pool = new Pool()\n  this.queue = ['TAP version 13\\n']\n  this.noparallel = false\n  this.cb = this.domain.bind(options.cb)\n  this.occupied = false\n  this.currentAssert = null\n  this.count = 0\n  this.n = 0\n  this.ended = false\n  this.explicitEnded = false\n  this.multiEndThrew = false\n  this.currentAssert = null\n  this.assertAt = null\n  this.assertStack = null\n  this.planEnd = -1\n  this.onBeforeEach = []\n  this.onAfterEach = []\n  this.ranAfterEach = false\n\n  // bind all methods to this object, so we can pass t.end as a callback\n  // and do `var test = require('tap').test` like people do.\n  var bound = Object.create(null)\n  bindObj(this, this, bound)\n  bindObj(this, Object.getPrototypeOf(this), bound)\n  bindObj(this, Test.prototype, bound)\n}\n\nTest.prototype.current = function () {\n  throw new Error('Test.current() as been removed and is no more')\n}\n\nTest.prototype.spawn = function spawn (cmd, args, options, name) {\n  if (typeof args === 'string') {\n    args = [ args ]\n  }\n\n  args = args || []\n\n  if (typeof options === 'string') {\n    name = options\n    options = {}\n  }\n\n  options = options || {}\n  options.name = ownOr(options, 'name', name)\n  options.command = cmd\n  options.args = args\n\n  return this.sub(Spawn, options, spawn)\n}\n\nTest.prototype.sub = function (Class, extra, caller) {\n  if (extra && (extra.todo || extra.skip)) {\n    this.pass(extra.name, extra)\n    return Promise.resolve(this)\n  }\n\n  extra.indent = '    '\n  if (this.jobs > 1 && process.env.TAP_BUFFER === undefined)\n    extra.buffered = ownOr(extra, 'buffered', true)\n  else\n    extra.buffered = ownOrEnv(extra, 'buffered', 'TAP_BUFFER', true)\n\n  extra.bail = ownOr(extra, 'bail', this.bail)\n  extra.parent = this\n  extra.stack = stack.captureString(80, caller)\n  var t = new Class(extra)\n\n  this.queue.push(t)\n  this.subtests.push(t)\n\n  var d = new Deferred()\n  t.deferred = d\n  this.process()\n  return d.promise\n}\n\nTest.prototype.test = function test (name, extra, cb) {\n  extra = parseTestArgs(name, extra, cb)\n  return this.sub(Test, extra, test)\n}\n\nTest.prototype.stdin = function stdin (name, extra) {\n  extra = parseTestArgs(name, extra, function () {}, '/dev/stdin')\n  return this.sub(Stdin, extra || {}, stdin)\n}\n\nTest.prototype.bailout = function (message) {\n  if (this.parent && (this.results || this.ended))\n    this.parent.bailout(message)\n  else {\n    this.process()\n    message = message ? ' ' + ('' + message).trim() : ''\n    message = message.replace(/[\\r\\n]/g, ' ')\n    this.parser.write('Bail out!' + message + '\\n')\n  }\n  this.end(IMPLICIT)\n  this.process()\n}\n\nTest.prototype.comment = function () {\n  var message = util.format.apply(util, arguments)\n  message = '# ' + message.split(/\\r?\\n/).join('\\n# ') + '\\n'\n\n  if (this.results)\n    this.push(message)\n  else\n    this.queue.push(message)\n  this.process()\n}\n\nTest.prototype.timeout = function (options) {\n  options = options || {}\n  options.expired = options.expired || this.name\n  if (this.occupied)\n    this.occupied.timeout(options)\n  else\n    Base.prototype.timeout.call(this, options)\n  this.end(IMPLICIT)\n}\n\nTest.prototype.main = function (cb) {\n  this.setTimeout(this.options.timeout)\n  this.debug('MAIN pre', this)\n\n  var self = this\n  try {\n    var ret = this.cb(this)\n  } catch (er) {\n    this.threw(er)\n  }\n\n  if (ret && ret.then) {\n    this.promise = ret\n    ret.tapAbortPromise = done\n    ret.then(end, done)\n  } else\n    done()\n\n  function end () {\n    self.debug(' > implicit end for promise')\n    self.end(IMPLICIT)\n    done()\n  }\n\n  function done (er) {\n    if (er)\n      self.threw(er)\n\n    if (self.results || self.bailedOut)\n      cb()\n    else\n      self.ondone = cb\n  }\n\n  this.debug('MAIN post', this)\n}\n\nTest.prototype.process = function () {\n  if (this.processing)\n    return this.debug(' < already processing')\n\n  this.debug('\\nPROCESSING(%s)', this.name, this.queue.length)\n  this.processing = true\n\n  var p\n\n  while (!this.occupied && (p = this.queue.shift())) {\n    this.debug('PROCESS(%s)', this.name, p)\n    if (p instanceof Base) {\n      this.processSubtest(p)\n    } else if (p === EOF) {\n      this.debug(' > EOF', this.name)\n      // I AM BECOME EOF, DESTROYER OF STREAMS\n      this.parser.end()\n    } else if (p instanceof TestPoint) {\n      this.debug(' > TESTPOINT')\n      this.parser.write(p.ok + (++this.n) + p.message)\n    } else if (typeof p === 'string') {\n      this.debug(' > STRING')\n      this.parser.write(p)\n    } else if (Array.isArray(p)) {\n      this.debug(' > METHOD')\n      var m = p.shift()\n      this[m].apply(this, p)\n    } else {\n      throw new Error('weird thing got in the queue')\n    }\n  }\n\n  while (!this.noparallel &&\n         this.pool.length < this.jobs &&\n         (p = this.subtests.shift())) {\n    if (!p.buffered) {\n      this.noparallel = true\n      break\n    }\n    this.debug('start subtest', p)\n    this.pool.add(p)\n    if (this.bailedOut)\n      this.onbufferedend(p)\n    else\n      this.runBeforeEach(p,\n        p.main.bind(p,\n          this.onbufferedend.bind(this, p)))\n  }\n\n  this.debug('done processing', this.queue, this.occupied)\n  this.processing = false\n\n  // just in case any tests ended, and we have sync stuff still\n  // waiting around in the queue to be processed\n  if (!this.occupied && this.queue.length)\n    this.process()\n\n  this.maybeAutoend()\n}\n\nTest.prototype.processSubtest = function (p) {\n  this.debug(' > subtest')\n  this.occupied = p\n  if (!p.buffered) {\n    if (this.bailedOut)\n      return this.onindentedend(p)\n    this.debug(' > subtest indented')\n    p.pipe(this.parser, { end: false })\n    this.runBeforeEach(p,\n      this.writeSubComment.bind(this, p,\n        p.main.bind(p,\n          this.onindentedend.bind(this, p))))\n  } else if (p.readyToProcess) {\n    this.debug(' > subtest buffered, finished')\n    // finished!  do the thing!\n    this.occupied = null\n    if (!p.passing() || !p.silent) {\n      this.queue.unshift(['emitSubTeardown', p])\n      this.printResult(p.passing(), p.name, p.options, true)\n    }\n  } else {\n    this.occupied = p\n    this.debug(' > subtest buffered, unfinished', p)\n    // unfinished buffered test.\n    // nothing to do yet, just leave it there.\n    this.queue.unshift(p)\n  }\n}\n\nTest.prototype.emitSubTeardown = function (p) {\n  try {\n    p.emit('teardown')\n  } catch (er) {\n    delete p.options.time\n    p.threw(er)\n  }\n}\n\nTest.prototype.writeSubComment = function (p, cb) {\n  var comment = '# Subtest'\n  if (p.name)\n    comment += ': ' + p.name\n  comment += '\\n'\n  this.parser.write(comment)\n  cb()\n}\n\nTest.prototype.onbufferedend = function (p, er) {\n  delete p.ondone\n  p.results = p.results || {}\n  p.readyToProcess = true\n  var to = p.options.timeout\n  if (to && p.passing())\n    var dur = Date.now() - p.start\n  if (dur && dur > to)\n    p.timeout()\n  else\n    p.setTimeout(false)\n  this.debug('%s.onbufferedend', this.name, p.name, p.results.bailout)\n  this.pool.remove(p)\n  p.options.tapChildBuffer = p.output || ''\n  p.options.stack = ''\n  if (p.time)\n    p.options.time = p.time\n  if (this.occupied === p)\n    this.occupied = null\n  if (er)\n    this.threw(er)\n  p.deferred.resolve(this)\n  this.process()\n}\n\nTest.prototype.onindentedend = function (p, er) {\n  delete p.ondone\n  this.debug('onindentedend', p)\n  this.noparallel = false\n  var sti = this.subtests.indexOf(p)\n  if (sti !== -1)\n    this.subtests.splice(sti, 1)\n  p.readyToProcess = true\n  p.results = p.results || {}\n  if (p.time)\n    p.options.time = p.time\n  var to = p.options.timeout\n  if (to && p.passing())\n    var dur = Date.now() - p.start\n  if (dur && dur > to)\n    p.timeout()\n  else\n    p.setTimeout(false)\n  this.debug('onindentedend %s(%s)', this.name, p.name, er || 'ok')\n  assert(this.occupied === p)\n  this.occupied = null\n  this.debug('OIE(%s) b>shift into queue', this.name, this.queue)\n  p.options.stack = ''\n\n  this.queue.unshift(['emitSubTeardown', p])\n  this.printResult(p.passing(), p.name, p.options, true)\n\n  this.debug('OIE(%s) shifted into queue', this.name, this.queue)\n  if (er)\n    this.threw(er)\n  p.deferred.resolve(this)\n  this.process()\n}\n\nTest.prototype.addAssert = function (name, length, fn) {\n  if (!name)\n    throw new TypeError('name is required for addAssert')\n\n  if (!(typeof length === 'number' && length >= 0))\n    throw new TypeError('number of args required')\n\n  if (typeof fn !== 'function')\n    throw new TypeError('function required for addAssert')\n\n  if (Test.prototype[name] || this[name])\n    throw new TypeError('attempt to re-define `' + name + '` assert')\n\n  this[name] = function ASSERT () {\n    if (!this.currentAssert) {\n      this.currentAssert = ASSERT\n    }\n    var args = new Array(length + 2)\n    for (var i = 0; i < length; i++) {\n      args[i] = arguments[i]\n    }\n    if (typeof arguments[length] === 'object') {\n      args[length] = ''\n      args[length + 1] = arguments[length]\n    } else {\n      args[length] = arguments[length] || ''\n      args[length + 1] = arguments[length + 1] || {}\n    }\n\n    return fn.apply(this, args)\n  }\n}\n\nTest.prototype.fail = function fail (message, extra) {\n  if (!this.currentAssert) {\n    this.currentAssert = fail\n  }\n\n  if (message && typeof message === 'object') {\n    extra = message\n    message = ''\n  } else {\n    if (!message) {\n      message = ''\n    }\n    if (!extra) {\n      extra = {}\n    }\n  }\n\n  this.printResult(false, message, extra)\n\n  var ret = true\n  if (!extra.todo && !extra.skip)\n    ret = false\n\n  return ret\n}\n\nTest.prototype.pass = function pass (message, extra) {\n  if (!this.currentAssert) {\n    this.currentAssert = pass\n  }\n  this.printResult(true, message || '(unnamed test)', extra)\n  return true\n}\n\nTest.prototype.printResult = function pR (ok, message, extra, front) {\n  var n = this.count + 1\n  if (this.planEnd !== -1 && n > this.planEnd) {\n    if (!this.passing())\n      return\n\n    var failMessage = this.explicitEnded\n        ? 'test after end() was called'\n        : 'test count exceeds plan'\n\n    var er = new Error(failMessage)\n    Error.captureStackTrace(er, this.currentAssert || pR)\n    er.test = this.name\n    er.plan = this.planEnd\n    this.threw(er)\n    return\n  }\n\n  extra = extra || {}\n\n  if (this.assertAt) {\n    extra.at = this.assertAt\n    this.assertAt = null\n  }\n\n  if (this.assertStack) {\n    extra.stack = this.assertStack\n    this.assertStack = null\n  }\n\n  if (hasOwn(extra, 'stack') && !hasOwn(extra, 'at'))\n    extra.at = stack.parseLine(extra.stack.split('\\n')[0])\n\n  var fn = this.currentAssert || pR\n  this.currentAssert = null\n  if (!ok && !extra.skip && !hasOwn(extra, 'at')) {\n    assert.equal(typeof fn, 'function')\n    extra.at = stack.at(fn)\n    if (!extra.todo)\n      extra.stack = stack.captureString(80, fn)\n  }\n\n  var diagnostic\n  if (!ok)\n    diagnostic = true\n\n  if (extra.skip)\n    diagnostic = false\n\n  if (process.env.TAP_DIAG === '0')\n    diagnostic = false\n\n  if (typeof extra.diagnostic === 'boolean')\n    diagnostic = extra.diagnostic\n\n  if (diagnostic)\n    extra.diagnostic = true\n\n  this.count = n\n  var res = { ok: ok, message: message, extra: extra }\n  var output = new TestPoint(ok, message, extra)\n  // when we jump the queue, skip an extra line\n  if (front)\n    output.message = output.message.trimRight() + '\\n\\n'\n\n  if (front) {\n    this.emit('result', res)\n    this.parser.write(output.ok + (++this.n) + output.message)\n  } else\n    this.queue.push(['emit', 'result', res], output)\n\n  if (this.planEnd === this.count)\n    this.end(IMPLICIT)\n\n  this.process()\n}\n\nTest.prototype.pragma = function (set) {\n  var p = ''\n  Object.keys(set).forEach(function (i) {\n    p += 'pragma ' + (set[i] ? '+' : '-') + i + '\\n'\n  })\n  this.queue.push(p)\n  this.process()\n}\n\nTest.prototype.plan = function (n, comment) {\n  if (this.bailedOut)\n    return\n\n  if (this.planEnd !== -1) {\n    throw new Error('Cannot set plan more than once')\n  }\n\n  if (typeof n !== 'number' || n < 0) {\n    throw new TypeError('plan must be a number')\n  }\n\n  // Cannot get any tests after a trailing plan, or a plan of 0\n  var ending = false\n  if (this.count !== 0 || n === 0) {\n    ending = true\n  }\n\n  if (n === 0)\n    this.skip = comment || true\n\n  this.planEnd = n\n  comment = comment ? ' # ' + comment.trim() : ''\n  this.queue.push('1..' + n + comment + '\\n')\n\n  if (ending)\n    this.end(IMPLICIT)\n  else\n    this.process()\n}\n\nTest.prototype.done = Test.prototype.end = function (implicit) {\n  this.debug('END implicit=%j', implicit === IMPLICIT)\n  if (this.ended && implicit === IMPLICIT)\n    return\n\n  // beyond here we have to be actually done with things, or else\n  // the semantic checks on counts and such will be off.\n  if (!queueEmpty(this) || this.occupied) {\n    if (!this.pushedEnd)\n      this.queue.push(['end', implicit])\n    this.pushedEnd = true\n    return this.process()\n  }\n\n  if (!this.ranAfterEach && this.parent) {\n    this.ranAfterEach = true\n    this.parent.runAfterEach(this, end.bind(this, implicit))\n  } else\n    end.call(this, implicit)\n}\n\nfunction end (implicit) {\n  this.ended = true\n\n  if (implicit !== IMPLICIT && !this.multiEndThrew) {\n    if (this.explicitEnded) {\n      this.multiEndThrew = true\n      var er = new Error('test end() method called more than once')\n      Error.captureStackTrace(er, this.currentAssert || end)\n      er.test = this.name\n      this.threw(er)\n      return\n    }\n    this.explicitEnded = true\n  }\n\n  if (this.planEnd === -1) {\n    this.debug('END(%s) implicit plan', this.name, this.count)\n    this.plan(this.count)\n  }\n\n  this.queue.push(EOF)\n  this.process()\n}\n\nTest.prototype.threw = function (er, extra, proxy) {\n  this.debug('THREW', er.message, extra, proxy)\n\n  // event emitters 'error' events need to re-throw so that they\n  // can jump out of the flow like a normal throw.  They'll just\n  // end up back here once that happens, though, unless there's a\n  // try/catch somewhere in the call stack.\n  if (er.domainEmitter) {\n    delete er.domainEmitter\n    throw er\n  }\n\n  if (this.name && !proxy)\n    er.test = this.name\n  if (!proxy)\n    extra = extraFromError(er, extra, this.options)\n  Base.prototype.threw.call(this, er, extra, proxy)\n\n  if (!this.results) {\n    this.fail(extra.message || er.message, extra)\n    if (!proxy)\n      this.end(IMPLICIT)\n  }\n  this.process()\n}\n\nTest.prototype.runBeforeEach = function (who, cb) {\n  var self = this\n  if (this.parent)\n    this.parent.runBeforeEach(who, function () {\n      loop(who, self.onBeforeEach, cb, who.threw)\n    })\n  else\n    loop(who, self.onBeforeEach, cb, who.threw)\n}\n\nTest.prototype.runAfterEach = function (who, cb) {\n  var self = this\n  loop(who, self.onAfterEach, function () {\n    if (self.parent)\n      self.parent.runAfterEach(who, cb)\n    else\n      cb()\n  }, who.threw)\n}\n\nTest.prototype.beforeEach = function (fn) {\n  this.onBeforeEach.push(fn)\n}\n\nTest.prototype.afterEach = function (fn) {\n  this.onAfterEach.push(fn)\n}\n\nTest.prototype.teardown = Test.prototype.tearDown = function (fn) {\n  this.on('teardown', fn)\n}\n\nTest.prototype.shouldAutoend = function () {\n  var should = (\n    this.options.autoend &&\n    !this.ended &&\n    !this.occupied &&\n    queueEmpty(this) &&\n    !this.pool.length &&\n    !this.subtests.length &&\n    this.planEnd === -1\n  )\n  return should\n}\n\nTest.prototype.autoend = function () {\n  this.options.autoend = true\n  this.maybeAutoend()\n}\n\nTest.prototype.maybeAutoend = function () {\n  if (this.autoendTimer)\n    clearTimeout(this.autoendTimer)\n\n  if (this.shouldAutoend()) {\n    var self = this\n    self.autoendTimer = setTimeout(function () {\n      if (self.shouldAutoend()) {\n        self.autoendTimer = setTimeout(function () {\n          if (self.shouldAutoend()) {\n            self.end(IMPLICIT)\n          }\n        })\n      }\n    })\n  }\n}\n\nfunction endAllQueue (queue) {\n  queue.forEach(function (p, i) {\n    if ((p instanceof Base) && !p.readyToProcess)\n      queue[i] = new TestPoint(false,\n        'child test left in queue ' + p.constructor.name + ': ' +\n        p.name, p.options)\n  })\n  queue.push(['end', IMPLICIT])\n}\n\nfunction queueEmpty (t) {\n  return t.queue.length === 0 ||\n    t.queue.length === 1 && t.queue[0] === 'TAP version 13\\n'\n}\n\nTest.prototype.endAll = function (sub) {\n  this.processing = true\n  if (this.occupied) {\n    var p = this.occupied\n    if (p.endAll)\n      p.endAll(true)\n    else {\n      p.parser.abort('test unfinished')\n    }\n  } else if (sub) {\n    this.process()\n    if (queueEmpty(this)) {\n      var options = Object.keys(this.options).reduce(function (o, k) {\n        o[k] = this.options[k]\n        return o\n      }.bind(this), {})\n      this.options.at = null\n      this.options.stack = ''\n      options.test = this.name\n      this.fail('test unfinished', options)\n    }\n  }\n  if (this.promise && this.promise.tapAbortPromise)\n    this.promise.tapAbortPromise()\n  if (this.occupied) {\n    this.queue.unshift(this.occupied)\n    this.occupied = null\n  }\n  endAllQueue(this.queue)\n  this.processing = false\n  this.process()\n  this.parser.end()\n}\n\n// Add all the asserts\ntapAsserts.decorate(Test.prototype)\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/base.js":"module.exports = Base\n\nvar Readable = require('stream').Readable\n/* istanbul ignore if */\nif (!Readable || process.version.match(/^v0\\.10/)) {\n  Readable = require('readable-stream').Readable\n}\n\nvar extraFromError = require('./extra-from-error.js')\nvar assert = require('assert')\nvar cleanYamlObject = require('./clean-yaml-object.js')\n\nvar domain = require('domain')\nvar util = require('util')\nutil.inherits(Base, Readable)\n\nvar Parser = require('tap-parser')\n\nvar ownOr = require('own-or')\nvar ownOrEnv = require('own-or-env')\n\nfunction Base (options) {\n  this.start = 0\n  this.hrtime = null\n  this.time = null\n  this.readyToProcess = false\n  this.options = options\n  this.parent = ownOr(options, 'parent', null)\n  this.bail = ownOrEnv(options, 'bail', 'TAP_BAIL', true)\n  this.name = ownOr(options, 'name', '')\n  if (!this.name)\n    this.name = ''\n  else\n    this.name = this.name.replace(/[\\n\\r\\s\\t]/g, ' ')\n  this.indent = ownOr(options, 'indent', '')\n  this.silent = !!options.silent\n  this.buffered = !!options.buffered || !!options.silent\n  this.finished = false\n  this.strict = ownOrEnv(options, 'strict', 'TAP_STRICT', true)\n  this.omitVersion = !!options.omitVersion\n  this.preserveWhitespace = ownOr(options, 'preserveWhitespace', true)\n  this.jobs = +ownOrEnv(options, 'jobs', 'TAP_JOBS') || 0\n  this.skip = ownOr(options, 'skip', false)\n  this.todo = ownOr(options, 'todo', false)\n  this.setupParser(options)\n  this.finished = false\n  this.output = ''\n  this.results = null\n  this.bailedOut = false\n  if (this.skip || this.todo)\n    this.main = Base.prototype.main\n\n  Readable.apply(this, options)\n\n  domain.create().add(this)\n  this.domain.on('error', this.threw.bind(this))\n\n  if (typeof options.debug === 'boolean')\n    this.debug = options.debug ? debug : nodebug\n}\n\nBase.prototype.passing = function () {\n  return this.parser.ok\n}\n\nBase.prototype.setTimeout = function (n) {\n  if (!this.hrtime)\n    this.hrtime = process.hrtime()\n\n  if (!n) {\n    clearTimeout(this.timer)\n    this.timer = null\n  } else {\n    this.start = Date.now()\n    this.timer = setTimeout(this.timeout.bind(this), n)\n    if (this.timer.unref)\n      this.timer.unref()\n  }\n}\n\nBase.prototype.threw = function (er, extra, proxy) {\n  if (this.name && !proxy)\n    er.test = this.name\n\n  var message = er.message\n\n  if (!extra)\n    extra = extraFromError(er, extra, this.options)\n\n  if (this.results || this.ended) {\n    this.results.ok = false\n    if (this.parent)\n      this.parent.threw(er, extra, true)\n    else if (!er.stack)\n      console.error(er)\n    else {\n      er.message = message\n      delete extra.stack\n      delete extra.at\n      console.error('%s: %s', er.name || 'Error', message)\n      console.error(er.stack.split(/\\n/).slice(1).join('\\n'))\n      console.error(extra)\n    }\n  } else\n    this.parser.ok = false\n\n  return extra\n}\n\nBase.prototype.timeout = function (options) {\n  this.setTimeout(false)\n  var er = new Error('timeout!')\n  options = options || {}\n  options.expired = options.expired || this.name\n  this.threw(new Error('timeout!'), options)\n}\n\nBase.prototype.main = function (cb) {\n  cb()\n}\n\nBase.prototype.online = function (line) {\n  this.debug('LINE %j', line)\n  return this.push(this.indent + line)\n}\n\nBase.prototype.push = function (c, e) {\n  assert.equal(typeof c, 'string')\n  assert.equal(c.substr(-1), '\\n')\n\n  if (this.buffered) {\n    this.output += c\n    return true\n  }\n\n  // We *always* want data coming out immediately.  Test runners have a\n  // very special relationship with zalgo. It's more important to ensure\n  // that any console.log() lines that appear in the midst of tests are\n  // not taken out of context\n  if (this._readableState) {\n    this._readableState.sync = false\n  }\n\n  // this.debug(this._readableState)\n  return Readable.prototype.push.call(this, c, e)\n}\n\nBase.prototype.onbail = function (reason) {\n  this.bailedOut = reason || true\n  this.emit('bailout', reason)\n}\n\nBase.prototype.oncomplete = function (results) {\n  if (this.hrtime) {\n    this.hrtime = process.hrtime(this.hrtime)\n    this.time = Math.round(this.hrtime[0] * 1e6 + this.hrtime[1] / 1e3) / 1e3\n  }\n\n  this.debug('ONCOMPLETE %j %j', this.name, results)\n\n  if (this.results)\n    Object.keys(this.results).forEach(function (k) {\n      results[k] = this.results[k]\n    }, this)\n\n  this.results = results\n  this.emit('complete', results)\n  var failures = results.failures.filter(function (f) {\n    delete f.diag\n    delete f.ok\n    return f.tapError\n  })\n\n  if (failures.length)\n    this.options.failures = failures\n\n  this.onbeforeend()\n  this.emit('end')\n  this.ondone()\n}\n\nBase.prototype.onbeforeend = function () {}\nBase.prototype.ondone = function () {}\n\nBase.prototype.setupParser = function (options) {\n  this.parser = new Parser({\n    bail: this.bail,\n    strict: this.strict,\n    omitVersion: this.omitVersion,\n    preserveWhitespace: this.preserveWhitespace\n  })\n  assert(this.parser.preserveWhitespace)\n  this.parser.on('line', this.online.bind(this))\n  this.parser.once('bailout', this.onbail.bind(this))\n  this.parser.on('complete', this.oncomplete.bind(this))\n}\n\nBase.prototype._read = function (n) {\n  // this.emit('readable')\n  // this.debug('_read %j', this.name, arguments)\n}\n\nBase.prototype.inspect = function () {\n  return this.constructor.name + ' ' + util.inspect({\n    name: this.name,\n    jobs: this.jobs,\n    buffered: this.buffered,\n    occupied: this.occupied,\n    pool: this.pool,\n    queue: this.queue,\n    subtests: this.subtests,\n    output: this.output,\n    skip: this.skip,\n    todo: this.todo,\n    results: this.results,\n    options: [\n      'autoend',\n      'command',\n      'args',\n      'stdio',\n      'env',\n      'cwd',\n      'exitCode',\n      'signal',\n      'expired',\n      'timeout',\n      'at',\n      'skip',\n      'todo'\n    ].reduce(function (set, k) {\n      if (this.options[k] !== undefined)\n        set[k] = this.options[k]\n      return set\n    }.bind(this), {})\n  })\n}\n\nBase.prototype.debug = (/\\btap\\b/i.test(process.env.NODE_DEBUG || ''))\n  ? debug : nodebug\n\nfunction nodebug () {}\n\n/* istanbul ignore next */\nfunction debug () {\n  var prefix = 'TAP ' + process.pid + ' ' + this.name + ': '\n  var msg = util.format.apply(util, arguments).trim()\n  msg = prefix + msg.split('\\n').join('\\n' + prefix)\n  console.error(msg)\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/extra-from-error.js":"var stack = require('./stack.js')\n\nmodule.exports = function (er, extra, options) {\n  extra = Object.keys(options || {}).reduce(function (set, k) {\n    if (!(k in set) && !/^tapChild/.test(k))\n      set[k] = options[k]\n    return set\n  }, extra || {})\n\n  if (!er || typeof er !== 'object') {\n    extra.error = er\n    return extra\n  }\n\n  var message = er.message\n  var addName = true\n\n  if (!message && er.stack) {\n    message = er.stack.split('\\n')[0]\n    addName = false\n  }\n\n  er.message = ''\n  var st = er.stack\n  if (st) {\n    st = st.split('\\n')\n    // parse out the 'at' bit from the first line.\n    extra.at = stack.parseLine(st[1])\n    extra.stack = stack.clean(st)\n  }\n  er.message = message\n\n  if (er.name && er.name !== 'Error')\n    extra.type = er.name\n\n  Object.keys(er).forEach(function (k) {\n    if (k === 'message' ||\n        k === 'domainEmitter' ||\n        k === 'domainThrown' ||\n        k === 'domain' ||\n        k === 'domainBound')\n      return\n    extra[k] = er[k]\n  })\n\n  return extra\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/stack.js":"var sourceMapSupport = require('source-map-support')\nvar StackUtils = require('stack-utils')\nvar path = require('path')\nvar tapDir = path.resolve(__dirname, '..')\n\n// don't skip when developing on tap itself\nvar skip = process.cwd() !== tapDir ||\n  +process.env.TAP_DEV_SHORTSTACK === 1 &&\n  +process.env.TAP_DEV_LONGSTACK !== 1\n? [\n    /node_modules[\\/\\\\]tap[\\/\\\\]/,\n    new RegExp(resc(tapDir) + '\\\\b', 'i'),\n    new RegExp(resc(require.resolve('function-loop'))),\n    new RegExp(resc(path.dirname(require.resolve('bluebird/package.json'))))\n  ]\n: []\n\nsourceMapSupport.install({environment:'node'})\n// Ignore tap if it's a dependency, or anything\n// in this lib folder.\nmodule.exports = new StackUtils({\n  internals: StackUtils.nodeInternals().concat(skip),\n  wrapCallSite: sourceMapSupport.wrapCallSite\n})\n\nfunction resc(str) {\n  return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/clean-yaml-object.js":"var cleanYamlObject = require('clean-yaml-object')\nvar path = require('path')\nvar Module = require('module')\nvar fs = require('fs')\nvar binpath = path.resolve(__dirname, '../bin')\nvar stack = require('./stack.js')\nvar Domain = require('domain').Domain\n\nfunction hasOwn (obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key)\n}\n\nmodule.exports = cleanTapYamlObject\n\nfunction cleanTapYamlObject (object) {\n  if (hasOwn(object, 'stack') && !hasOwn(object, 'at'))\n    object.at = stack.parseLine(object.stack.split('\\n')[0])\n\n  var file = object.at && object.at.file && path.resolve(object.at.file)\n  if (file && (file.indexOf(__dirname) === 0 || file.indexOf(binpath) === 0))\n    delete object.at\n\n  if (object.at && object.at.file && object.at.line && !object.source) {\n    var content\n    file = path.resolve(object.at.file)\n    try {\n      content = Module.wrap(fs.readFileSync(file))\n    } catch (er) {}\n    if (content) {\n      content = (content.split('\\n')[object.at.line - 1] || '').trim()\n      if (content)\n        object.source = content + '\\n'\n    }\n  }\n\n  return cleanYamlObject(object, yamlFilter)\n}\n\nfunction yamlFilter (propertyName, isRoot, source, target) {\n  if (source instanceof Domain)\n    return false\n\n  if (!isRoot)\n    return true\n\n  if (propertyName === 'stack') {\n    if (source.stack)\n      target.stack = source.stack\n    return false\n  }\n\n  return !(propertyName === 'todo' ||\n  propertyName === 'time' ||\n  /^_?tapChild/.test(propertyName) ||\n  /^tapStream/.test(propertyName) ||\n  /^tapMochaTest/.test(propertyName) ||\n  propertyName === 'cb' ||\n  propertyName === 'name' ||\n  propertyName === 'indent' ||\n  propertyName === 'skip' ||\n  propertyName === 'bail' ||\n  propertyName === 'diagnostic' ||\n  propertyName === 'buffered' ||\n  propertyName === 'parent' ||\n  propertyName === 'domainEmitter' ||\n  propertyName === 'domainThrew' ||\n  propertyName === 'domain' ||\n  (propertyName === 'at' && !source.at))\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap-parser/index.js":"// Transforms a stream of TAP into a stream of result objects\n// and string comments.  Emits \"results\" event with summary.\nvar Writable = require('stream').Writable\n/* istanbul ignore if */\nif (!Writable) {\n  try {\n    Writable = require('readable-stream').Writable\n  } catch (er) {\n    throw new Error('Please install \"readable-stream\" to use this module ' +\n                    'with Node.js v0.8 and before')\n  }\n}\n\nvar yaml = require('js-yaml')\nvar util = require('util')\nvar assert = require('assert')\n\nutil.inherits(Parser, Writable)\n\nmodule.exports = Parser\n\n// every line outside of a yaml block is one of these things, or\n// a comment, or garbage.\nvar lineTypes = {\n  testPoint: /^(not )?ok(?: ([0-9]+))?(?:(?: -)?( .*?))?(\\{?)\\n$/,\n  pragma: /^pragma ([+-])([a-z]+)\\n$/,\n  bailout: /^bail out!(.*)\\n$/i,\n  version: /^TAP version ([0-9]+)\\n$/i,\n  childVersion: /^(    )+TAP version ([0-9]+)\\n$/i,\n  plan: /^([0-9]+)\\.\\.([0-9]+)(?:\\s+(?:#\\s*(.*)))?\\n$/,\n  subtest: /^# Subtest(?:: (.*))?\\n$/,\n  subtestIndent: /^    # Subtest(?:: (.*))?\\n$/,\n  comment: /^\\s*#.*\\n$/\n}\n\nvar lineTypeNames = Object.keys(lineTypes)\n\nfunction lineType (line) {\n  for (var t in lineTypes) {\n    var match = line.match(lineTypes[t])\n    if (match)\n      return [t, match]\n  }\n  return null\n}\n\nfunction parseDirective (line) {\n  if (!line.trim())\n    return false\n\n  line = line.replace(/\\{\\s*$/, '').trim()\n  var time = line.match(/^time=((?:[1-9][0-9]*|0)(?:\\.[0-9]+)?)(ms|s)$/i)\n  if (time) {\n    var n = +time[1]\n    if (time[2] === 's') {\n      // JS does weird things with floats.  Round it off a bit.\n      n *= 1000000\n      n = Math.round(n)\n      n /= 1000\n    }\n    return [ 'time', n ]\n  }\n\n  var type = line.match(/^(todo|skip)\\b/i)\n  if (!type)\n    return false\n\n  return [ type[1].toLowerCase(), line.substr(type[1].length).trim() || true ]\n}\n\nfunction Result (parsed, count) {\n  var ok = !parsed[1]\n  var id = +(parsed[2] || count + 1)\n  var buffered = parsed[4]\n  this.ok = ok\n  this.id = id\n\n  var rest = parsed[3] || ''\n  var name\n  rest = rest.replace(/([^\\\\]|^)((?:\\\\\\\\)*)#/g, '$1\\n$2').split('\\n')\n  name = rest.shift()\n  rest = rest.filter(function (r) { return r.trim() }).join('#')\n\n  // now, let's see if there's a directive in there.\n  var dir = parseDirective(rest.trim())\n  if (!dir)\n    name += (rest ? '#' + rest : '') + buffered\n  else {\n    // handle buffered subtests with todo/skip on them, like\n    // ok 1 - bar # todo foo {\\n\n    var dirKey = dir[0]\n    var dirValue = dir[1]\n    this[dirKey] = dirValue\n  }\n\n  if (/\\{\\s*$/.test(name)) {\n    name = name.replace(/\\{\\s*$/, '')\n    buffered = '{'\n  }\n\n  if (buffered === '{')\n    this.buffered = true\n\n  if (name)\n    this.name = name.trim()\n\n  return this\n}\n\nfunction Parser (options, onComplete) {\n  if (typeof options === 'function') {\n    onComplete = options\n    options = {}\n  }\n\n  if (!(this instanceof Parser))\n    return new Parser(options, onComplete)\n\n  options = options || {}\n  if (onComplete)\n    this.on('complete', onComplete)\n\n  this.comments = []\n  this.results = null\n  this.braceLevel = null\n  this.parent = options.parent || null\n  this.failures = []\n  this.level = options.level || 0\n  Writable.call(this)\n  this.buffer = ''\n  this.bail = !!options.bail\n  this.bailingOut = false\n  this.bailedOut = false\n  this.syntheticBailout = false\n  this.syntheticPlan = false\n  this.omitVersion = !!options.omitVersion\n  this.planStart = -1\n  this.planEnd = -1\n  this.planComment = ''\n  this.yamlish = ''\n  this.yind = ''\n  this.child = null\n  this.current = null\n  this.maybeSubtest = null\n  this.extraQueue = []\n  this.buffered = options.buffered || null\n  this.aborted = false\n  this.preserveWhitespace = options.preserveWhitespace || false\n\n  this.count = 0\n  this.pass = 0\n  this.fail = 0\n  this.todo = 0\n  this.skip = 0\n  this.ok = true\n\n  this.strict = options.strict || false\n  this.pragmas = { strict: this.strict }\n\n  this.postPlan = false\n}\n\nParser.prototype.tapError = function (error, line) {\n  if (line)\n    this.emit('line', line)\n  this.ok = false\n  this.fail ++\n  if (typeof error === 'string') {\n    error = {\n      tapError: error\n    }\n  }\n  this.failures.push(error)\n}\n\nParser.prototype.parseTestPoint = function (testPoint, line) {\n  this.emitResult()\n  if (this.bailedOut)\n    return\n\n  this.emit('line', line)\n  var res = new Result(testPoint, this.count)\n  if (this.planStart !== -1) {\n    var lessThanStart = +res.id < this.planStart\n    var greaterThanEnd = +res.id > this.planEnd\n    if (lessThanStart || greaterThanEnd) {\n      if (lessThanStart)\n        res.tapError = 'id less than plan start'\n      else\n        res.tapError = 'id greater than plan end'\n      res.plan = { start: this.planStart, end: this.planEnd }\n      this.tapError(res)\n    }\n  }\n\n  if (res.id) {\n    if (!this.first || res.id < this.first)\n      this.first = res.id\n    if (!this.last || res.id > this.last)\n      this.last = res.id\n  }\n\n  if (!res.skip && !res.todo)\n    this.ok = this.ok && res.ok\n\n  // hold onto it, because we might get yamlish diagnostics\n  this.current = res\n}\n\nParser.prototype.nonTap = function (data, didLine) {\n  if (this.bailingOut && /^( {4})*\\}\\n$/.test(data))\n    return\n\n  if (this.strict) {\n    var err = {\n      tapError: 'Non-TAP data encountered in strict mode',\n      data: data\n    }\n    this.tapError(err)\n    if (this.parent)\n      this.parent.tapError(err)\n  }\n\n  // emit each line, then the extra as a whole\n  if (!didLine)\n    data.split('\\n').slice(0, -1).forEach(function (line) {\n      line += '\\n'\n      if (this.current || this.extraQueue.length)\n        this.extraQueue.push(['line', line])\n      else\n        this.emit('line', line)\n    }, this)\n\n  if (this.current || this.extraQueue.length)\n    this.extraQueue.push(['extra', data])\n  else\n    this.emit('extra', data)\n}\n\nParser.prototype.plan = function (start, end, comment, line) {\n  // not allowed to have more than one plan\n  if (this.planStart !== -1) {\n    this.nonTap(line)\n    return\n  }\n\n  // can't put a plan in a child.\n  if (this.child || this.yind) {\n    this.nonTap(line)\n    return\n  }\n\n  this.emitResult()\n  if (this.bailedOut)\n    return\n\n  // 1..0 is a special case. Otherwise, end must be >= start\n  if (end < start && end !== 0 && start !== 1) {\n    if (this.strict)\n      this.tapError({\n        tapError: 'plan end cannot be less than plan start',\n        plan: {\n          start: start,\n          end: end\n        }\n      }, line)\n    else\n      this.nonTap(line)\n    return\n  }\n\n  this.planStart = start\n  this.planEnd = end\n  var p = { start: start, end: end }\n  if (comment)\n    this.planComment = p.comment = comment\n\n  // This means that the plan is coming at the END of all the tests\n  // Plans MUST be either at the beginning or the very end.  We treat\n  // plans like '1..0' the same, since they indicate that no tests\n  // will be coming.\n  if (this.count !== 0 || this.planEnd === 0)\n    this.postPlan = true\n\n  this.emit('line', line)\n  this.emit('plan', p)\n}\n\nParser.prototype.resetYamlish = function () {\n  this.yind = ''\n  this.yamlish = ''\n}\n\n// that moment when you realize it's not what you thought it was\nParser.prototype.yamlGarbage = function () {\n  var yamlGarbage = this.yind + '---\\n' + this.yamlish\n  this.emitResult()\n  if (this.bailedOut)\n    return\n  this.nonTap(yamlGarbage, true)\n}\n\nParser.prototype.yamlishLine = function (line) {\n  if (line === this.yind + '...\\n') {\n    // end the yaml block\n    this.processYamlish()\n  } else {\n    this.yamlish += line\n  }\n}\n\nParser.prototype.processYamlish = function () {\n  var yamlish = this.yamlish\n  this.resetYamlish()\n\n  try {\n    var diags = yaml.safeLoad(yamlish)\n  } catch (er) {\n    this.nonTap(this.yind + '---\\n' + yamlish + this.yind + '...\\n', true)\n    return\n  }\n\n  this.current.diag = diags\n  // we still don't emit the result here yet, to support diags\n  // that come ahead of buffered subtests.\n}\n\nParser.prototype.write = function (chunk, encoding, cb) {\n  if (this.aborted)\n    return\n\n  if (typeof encoding === 'string' && encoding !== 'utf8')\n    chunk = new Buffer(chunk, encoding)\n\n  if (Buffer.isBuffer(chunk))\n    chunk += ''\n\n  if (typeof encoding === 'function') {\n    cb = encoding\n    encoding = null\n  }\n\n  this.buffer += chunk\n  do {\n    var match = this.buffer.match(/^.*\\r?\\n/)\n    if (!match)\n      break\n\n    this.buffer = this.buffer.substr(match[0].length)\n    this.parse(match[0])\n  } while (this.buffer.length)\n\n  if (cb)\n    process.nextTick(cb)\n  return true\n}\n\nParser.prototype.end = function (chunk, encoding, cb) {\n  if (chunk) {\n    if (typeof encoding === 'function') {\n      cb = encoding\n      encoding = null\n    }\n    this.write(chunk, encoding)\n  }\n\n  if (this.buffer)\n    this.write('\\n')\n\n  // if we have yamlish, means we didn't finish with a ...\n  if (this.yamlish)\n    this.yamlGarbage()\n\n  this.emitResult()\n\n  if (this.syntheticBailout && this.level === 0) {\n    var reason = this.bailedOut\n    if (reason === true)\n      reason = ''\n    else\n      reason = ' ' + reason\n    this.emit('line', 'Bail out!' + reason + '\\n')\n  }\n\n  var skipAll\n\n  if (this.planEnd === 0 && this.planStart === 1) {\n    skipAll = true\n    if (this.count === 0) {\n      this.ok = true\n    } else {\n      this.tapError('Plan of 1..0, but test points encountered')\n    }\n  } else if (!this.bailedOut && this.planStart === -1) {\n    if (this.count === 0 && !this.syntheticPlan) {\n      this.syntheticPlan = true\n      this.plan(1, 0, 'no tests found', '1..0 # no tests found\\n')\n      skipAll = true\n    } else {\n      this.tapError('no plan')\n    }\n  } else if (this.ok && this.count !== (this.planEnd - this.planStart + 1)) {\n    this.tapError('incorrect number of tests')\n  }\n\n  if (this.ok && !skipAll && this.first !== this.planStart) {\n    this.tapError('first test id does not match plan start')\n  }\n\n  if (this.ok && !skipAll && this.last !== this.planEnd) {\n    this.tapError('last test id does not match plan end')\n  }\n\n  Writable.prototype.end.call(this, null, null, cb)\n  this.emitComplete(skipAll)\n}\n\nParser.prototype.emitComplete = function (skipAll) {\n  if (!this.results) {\n    var res = this.results = new FinalResults(!!skipAll, this)\n\n    if (!res.bailout) {\n      // comment a bit at the end so we know what happened.\n      // but don't repeat these comments if they're already present.\n      if (res.plan.end !== res.count)\n        this.emitComment('test count(' + res.count +\n                         ') != plan(' + res.plan.end + ')', false, true)\n\n      if (res.fail > 0 && !res.ok)\n        this.emitComment('failed ' + res.fail +\n                         (res.count > 1 ? ' of ' + res.count + ' tests'\n                          : ' test'),\n                         false, true)\n\n      if (res.todo > 0)\n        this.emitComment('todo: ' + res.todo, false, true)\n\n      if (res.skip > 0)\n        this.emitComment('skip: ' + res.skip, false, true)\n    }\n\n    this.emit('complete', this.results)\n  }\n}\n\nfunction FinalResults (skipAll, self) {\n  this.ok = self.ok\n  this.count = self.count\n  this.pass = self.pass\n  this.fail = self.fail || 0\n  this.bailout = self.bailedOut || false\n  this.todo = self.todo || 0\n  this.skip = skipAll ? self.count : self.skip || 0\n  this.plan = new FinalPlan(skipAll, self)\n  this.failures = self.failures\n}\n\nfunction FinalPlan (skipAll, self) {\n  this.start = self.planStart === -1 ? null : self.planStart\n  this.end = self.planStart === -1 ? null : self.planEnd\n  this.skipAll = skipAll\n  this.skipReason = skipAll ? self.planComment : ''\n  this.comment = self.planComment || ''\n}\n\nParser.prototype.version = function (version, line) {\n  // If version is specified, must be at the very beginning.\n  if (version >= 13 &&\n      this.planStart === -1 &&\n      this.count === 0 &&\n      !this.current) {\n    this.emit('line', line)\n    this.emit('version', version)\n  } else\n    this.nonTap(line)\n}\n\nParser.prototype.pragma = function (key, value, line) {\n  // can't put a pragma in a child or yaml block\n  if (this.child) {\n    this.nonTap(line)\n    return\n  }\n\n  this.emitResult()\n  if (this.bailedOut)\n    return\n  // only the 'strict' pragma is currently relevant\n  if (key === 'strict') {\n    this.strict = value\n  }\n  this.pragmas[key] = value\n  this.emit('line', line)\n  this.emit('pragma', key, value)\n}\n\nParser.prototype.bailout = function (reason, synthetic) {\n  this.syntheticBailout = synthetic\n\n  if (this.bailingOut)\n    return\n\n  // Guard because emitting a result can trigger a forced bailout\n  // if the harness decides that failures should be bailouts.\n  this.bailingOut = reason || true\n\n  if (!synthetic)\n    this.emitResult()\n  else\n    this.current = null\n\n  this.bailedOut = this.bailingOut\n  this.ok = false\n  if (!synthetic) {\n    // synthetic bailouts get emitted on end\n    var line = 'Bail out!'\n    if (reason)\n      line += ' ' + reason\n    this.emit('line', line + '\\n')\n  }\n  this.emit('bailout', reason)\n  if (this.parent) {\n    this.end()\n    this.parent.bailout(reason, true)\n  }\n}\n\nParser.prototype.clearExtraQueue = function () {\n  for (var c = 0; c < this.extraQueue.length; c++) {\n    this.emit(this.extraQueue[c][0], this.extraQueue[c][1])\n  }\n  this.extraQueue.length = 0\n}\n\nParser.prototype.endChild = function () {\n  if (this.child) {\n    this.child.end()\n    this.child = null\n  }\n}\n\nParser.prototype.emitResult = function () {\n  if (this.bailedOut)\n    return\n\n  this.endChild()\n  this.resetYamlish()\n\n  if (!this.current)\n    return this.clearExtraQueue()\n\n  var res = this.current\n  this.current = null\n\n  this.count++\n  if (res.ok) {\n    this.pass++\n  } else {\n    this.fail++\n    if (!res.todo && !res.skip) {\n      this.ok = false\n      this.failures.push(res)\n    }\n  }\n\n  if (res.skip)\n    this.skip++\n\n  if (res.todo)\n    this.todo++\n\n  this.emit('assert', res)\n  if (this.bail && !res.ok && !res.todo && !res.skip && !this.bailingOut) {\n    this.maybeChild = null\n    var ind = new Array(this.level + 1).join('    ')\n    for (var p = this; p.parent; p = p.parent);\n    var bailName = res.name ? ' # ' + res.name : ''\n    p.parse(ind + 'Bail out!' + bailName + '\\n')\n  }\n  this.clearExtraQueue()\n}\n\n// TODO: We COULD say that any \"relevant tap\" line that's indented\n// by 4 spaces starts a child test, and just call it 'unnamed' if\n// it does not have a prefix comment.  In that case, any number of\n// 4-space indents can be plucked off to try to find a relevant\n// TAP line type, and if so, start the unnamed child.\nParser.prototype.startChild = function (line) {\n  var maybeBuffered = this.current && this.current.buffered\n  var unindentStream = !maybeBuffered && this.maybeChild\n  var indentStream = !maybeBuffered && !unindentStream &&\n    lineTypes.subtestIndent.test(line)\n  var unnamed = !maybeBuffered && !unindentStream && !indentStream\n\n  // If we have any other result waiting in the wings, we need to emit\n  // that now.  A buffered test emits its test point at the *end* of\n  // the child subtest block, so as to match streamed test semantics.\n  if (!maybeBuffered)\n    this.emitResult()\n\n  if (this.bailedOut)\n    return\n\n  this.child = new Parser({\n    bail: this.bail,\n    parent: this,\n    level: this.level + 1,\n    buffered: maybeBuffered,\n    preserveWhitespace: this.preserveWhitespace,\n    omitVersion: true,\n    strict: this.strict\n  })\n\n  var self = this\n  this.child.on('complete', function (results) {\n    if (!results.ok)\n      self.ok = false\n  })\n\n  this.child.on('line', function (l) {\n    if (this.syntheticPlan)\n      return\n\n    if (l.trim() || self.preserveWhitespace)\n      l = '    ' + l\n    self.emit('line', l)\n  })\n\n  // Canonicalize the parsing result of any kind of subtest\n  // if it's a buffered subtest or a non-indented Subtest directive,\n  // then synthetically emit the Subtest comment\n  line = line.substr(4)\n  var subtestComment\n  if (indentStream) {\n    subtestComment = line\n    line = null\n  } else if (maybeBuffered) {\n    subtestComment = '# Subtest: ' + this.current.name + '\\n'\n  } else {\n    subtestComment = this.maybeChild || '# Subtest: (anonymous)\\n'\n  }\n\n  this.maybeChild = null\n  this.child.name = subtestComment.substr('# Subtest: '.length).trim()\n\n  // at some point, we may wish to move 100% to preferring\n  // the Subtest comment on the parent level.  If so, uncomment\n  // this line, and remove the child.emitComment below.\n  // this.emit('comment', subtestComment)\n  if (!this.child.buffered)\n    this.emit('line', subtestComment)\n  this.emit('child', this.child)\n  this.child.emitComment(subtestComment, true)\n  if (line)\n    this.child.parse(line)\n}\n\nParser.prototype.abort = function (message, extra) {\n  if (this.child) {\n    var b = this.child.buffered\n    this.child.abort(message, extra)\n    extra = null\n    if (b)\n      this.write('\\n}\\n')\n  }\n\n  var dump\n  if (extra && Object.keys(extra).length) {\n    try {\n      dump = yaml.safeDump(extra).trimRight()\n    } catch (er) {}\n  }\n\n  var y\n  if (dump)\n    y = '  ---\\n  ' + dump.split('\\n').join('\\n  ') + '\\n  ...\\n'\n  else\n    y = '\\n'\n  var n = (this.count || 0) + 1\n  if (this.current)\n    n += 1\n\n  if (this.planEnd !== -1 && this.planEnd < n && this.parent) {\n    // skip it, let the parent do this.\n    this.aborted = true\n    return\n  }\n\n  var ind = '' // new Array(this.level + 1).join('    ')\n  message = message.replace(/[\\n\\r\\s\\t]/g, ' ')\n  var point = '\\nnot ok ' + n + ' - ' + message + '\\n' + y\n\n  if (this.planEnd === -1)\n    point += '1..' + n + '\\n'\n\n  this.write(point)\n  this.aborted = true\n  this.end()\n}\n\nParser.prototype.emitComment = function (line, skipLine, noDuplicate) {\n  if (line.trim().charAt(0) !== '#')\n    line = '# ' + line\n\n  if (line.slice(-1) !== '\\n')\n    line += '\\n'\n\n  if (noDuplicate && this.comments.indexOf(line) !== -1)\n    return\n\n  this.comments.push(line)\n  if (this.current || this.extraQueue.length) {\n    // no way to get here with skipLine being true\n    this.extraQueue.push(['line', line])\n    this.extraQueue.push(['comment', line])\n  } else {\n    if (!skipLine)\n      this.emit('line', line)\n    this.emit('comment', line)\n  }\n}\n\nParser.prototype.parse = function (line) {\n  // normalize line endings\n  line = line.replace(/\\r\\n$/, '\\n')\n\n  // sometimes empty lines get trimmed, but are still part of\n  // a subtest or a yaml block.  Otherwise, nothing to parse!\n  if (line === '\\n') {\n    if (this.child)\n      line = '    ' + line\n    else if (this.yind)\n      line = this.yind + line\n  }\n\n  // If we're bailing out, then the only thing we want to see is the\n  // end of a buffered child test.  Anything else should be ignored.\n  // But!  if we're bailing out a nested child, and ANOTHER nested child\n  // comes after that one, then we don't want the second child's } to\n  // also show up, or it looks weird.\n  if (this.bailingOut) {\n    if (!/^\\s*}\\n$/.test(line))\n      return\n    else if (!this.braceLevel || line.length < this.braceLevel)\n      this.braceLevel = line.length\n    else\n      return\n  }\n\n  // This allows omitting even parsing the version if the test is\n  // an indented child test.  Several parsers get upset when they\n  // see an indented version field.\n  if (this.omitVersion && lineTypes.version.test(line) && !this.yind)\n    return\n\n  // check to see if the line is indented.\n  // if it is, then it's either a subtest, yaml, or garbage.\n  var indent = line.match(/^[ \\t]*/)[0]\n  if (indent) {\n    this.parseIndent(line, indent)\n    return\n  }\n\n  // In any case where we're going to emitResult, that can trigger\n  // a bailout, so we need to only emit the line once we know that\n  // isn't happening, to prevent cases where there's a bailout, and\n  // then one more line of output.  That'll also prevent the case\n  // where the test point is emitted AFTER the line that follows it.\n\n  // buffered subtests must end with a }\n  if (this.child && this.child.buffered && line === '}\\n') {\n    this.endChild()\n    this.emit('line', line)\n    this.emitResult()\n    return\n  }\n\n  // just a \\n, emit only if we care about whitespace\n  var validLine = this.preserveWhitespace || line.trim() || this.yind\n  if (line === '\\n')\n    return validLine && this.emit('line', line)\n\n  // buffered subtest with diagnostics\n  if (this.current && line === '{\\n' &&\n      !this.current.buffered &&\n      !this.child) {\n    this.emit('line', line)\n    this.current.buffered = true\n    return\n  }\n\n  // now we know it's not indented, so if it's either valid tap\n  // or garbage.  Get the type of line.\n  var type = lineType(line)\n  if (!type) {\n    this.nonTap(line)\n    return\n  }\n\n  if (type[0] === 'comment') {\n    this.emitComment(line)\n    return\n  }\n\n  // if we have any yamlish, it's garbage now.  We tolerate non-TAP and\n  // comments in the midst of yaml (though, perhaps, that's questionable\n  // behavior), but any actual TAP means that the yaml block was just\n  // not valid.\n  if (this.yind)\n    this.yamlGarbage()\n\n  // If it's anything other than a comment or garbage, then any\n  // maybeChild is just an unsatisfied promise.\n  if (this.maybeChild) {\n    this.emitComment(this.maybeChild)\n    this.maybeChild = null\n  }\n\n  // nothing but comments can come after a trailing plan\n  if (this.postPlan) {\n    this.nonTap(line)\n    return\n  }\n\n  // ok, now it's maybe a thing\n  if (type[0] === 'bailout') {\n    this.bailout(type[1][1].trim(), false)\n    return\n  }\n\n  if (type[0] === 'pragma') {\n    var pragma = type[1]\n    this.pragma(pragma[2], pragma[1] === '+', line)\n    return\n  }\n\n  if (type[0] === 'version') {\n    var version = type[1]\n    this.version(parseInt(version[1], 10), line)\n    return\n  }\n\n  if (type[0] === 'plan') {\n    var plan = type[1]\n    this.plan(+plan[1], +plan[2], (plan[3] || '').trim(), line)\n    return\n  }\n\n  // streamed subtests will end when this test point is emitted\n  if (type[0] === 'testPoint') {\n    // note: it's weird, but possible, to have a testpoint ending in\n    // { before a streamed subtest which ends with a test point\n    // instead of a }.  In this case, the parser gets confused, but\n    // also, even beginning to handle that means doing a much more\n    // involved multi-line parse.  By that point, the subtest block\n    // has already been emitted as a 'child' event, so it's too late\n    // to really do the optimal thing.  The only way around would be\n    // to buffer up everything and do a multi-line parse.  This is\n    // rare and weird, and a multi-line parse would be a bigger\n    // rewrite, so I'm allowing it as it currently is.\n    this.parseTestPoint(type[1], line)\n    return\n  }\n\n  // We already detected nontap up above, so the only case left\n  // should be a `# Subtest:` comment.  Ignore for coverage, but\n  // include the error here just for good measure.\n  /* istanbul ignore else */\n  if (type[0] === 'subtest') {\n    // this is potentially a subtest.  Not indented.\n    // hold until later.\n    this.maybeChild = line\n  } else {\n    throw new Error('Unhandled case: ' + type[0])\n  }\n}\n\nParser.prototype.parseIndent = function (line, indent) {\n  // still belongs to the child, so pass it along.\n  if (this.child && line.substr(0, 4) === '    ') {\n    line = line.substr(4)\n    this.child.write(line)\n    return\n  }\n\n  // one of:\n  // - continuing yaml block\n  // - starting yaml block\n  // - ending yaml block\n  // - body of a new child subtest that was previously introduced\n  // - An indented subtest directive\n  // - A comment, or garbage\n\n  // continuing/ending yaml block\n  if (this.yind) {\n    if (line.indexOf(this.yind) === 0) {\n      this.emit('line', line)\n      this.yamlishLine(line)\n      return\n    } else {\n      // oops!  that was not actually yamlish, I guess.\n      // this is a case where the indent is shortened mid-yamlish block\n      // treat existing yaml as garbage, continue parsing this line\n      this.yamlGarbage()\n    }\n  }\n\n\n  // start a yaml block under a test point\n  if (this.current && !this.yind && line === indent + '---\\n') {\n    this.yind = indent\n    this.emit('line', line)\n    return\n  }\n\n  // at this point, not yamlish, and not an existing child test.\n  // We may have already seen an unindented Subtest directive, or\n  // a test point that ended in { indicating a buffered subtest\n  // Child tests are always indented 4 spaces.\n  if (line.substr(0, 4) === '    ') {\n    if (this.maybeChild ||\n        this.current && this.current.buffered ||\n        lineTypes.subtestIndent.test(line)) {\n      this.startChild(line)\n      return\n    }\n\n    // It's _something_ indented, if the indentation is divisible by\n    // 4 spaces, and the result is actual TAP of some sort, then do\n    // a child subtest for it as well.\n    //\n    // This will lead to some ambiguity in cases where there are multiple\n    // levels of non-signaled subtests, but a Subtest comment in the\n    // middle of them, which may or may not be considered \"indented\"\n    // See the subtest-no-comment-mid-comment fixture for an example\n    // of this.  As it happens, the preference is towards an indented\n    // Subtest comment as the interpretation, which is the only possible\n    // way to resolve this, since otherwise there's no way to distinguish\n    // between an anonymous subtest with a non-indented Subtest comment,\n    // and an indented Subtest comment.\n    var s = line.match(/( {4})+(.*\\n)$/)\n    if (s[2].charAt(0) !== ' ') {\n      // integer number of indentations.\n      var type = lineType(s[2])\n      if (type) {\n        if (type[0] === 'comment') {\n          this.emit('line', line)\n          this.emitComment(line)\n        } else {\n          // it's relevant!  start as an \"unnamed\" child subtest\n          this.startChild(line)\n        }\n        return\n      }\n    }\n  }\n\n  // at this point, it's either a non-subtest comment, or garbage.\n\n  if (lineTypes.comment.test(line)) {\n    this.emitComment(line)\n    return\n  }\n\n  this.nonTap(line)\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/spawn.js":"var Base = require('./base.js')\n\nvar assert = require('assert')\nvar util = require('util')\nutil.inherits(Spawn, Base)\nvar ownOr = require('own-or')\nvar path = require('path')\nvar cleanYamlObject = require('./clean-yaml-object.js')\n\nmodule.exports = Spawn\n\nvar cp = require('child_process')\nvar spawn = cp.spawn\n\nfunction Spawn (options) {\n  options = options || {}\n  if (!(this instanceof Spawn))\n    return new Spawn(options)\n\n  Base.call(this, options)\n\n  this.command = options.command\n\n  if (!this.command)\n    throw new TypeError('no command provided')\n\n  this.args = options.args\n  // stdout must be a pipe\n  if (options.stdio) {\n    if (typeof options.stdio === 'string')\n      this.stdio = [ options.stdio, 'pipe', options.stdio ]\n    else\n      this.stdio = options.stdio.slice(0)\n  } else\n    this.stdio = [ 0, 'pipe', 2 ]\n\n  this.stdio[1] = 'pipe'\n  var env = options.env || process.env\n  this.env = Object.keys(env).reduce(function (e, k) {\n    e[k] = env[k]\n    return e\n  }, {})\n\n  this.env.TAP = '1'\n  if (this.bail)\n    this.env.TAP_BAIL = '1'\n\n  this.cwd = ownOr(options, 'cwd', process.cwd())\n  options.cwd = this.cwd\n  if (!this.name) {\n    if (this.command === process.execPath) {\n      this.name = path.basename(process.execPath) + ' ' +\n        this.args.map(function (a) {\n          if (a.indexOf(this.cwd) === 0) {\n            return './' +\n              a.substr(this.cwd.length + 1).replace(/\\\\/g, '/')\n          } else {\n            return a\n          }\n        }, this).join(' ')\n    } else {\n      this.name = this.command + ' ' + this.args.join(' ')\n    }\n  }\n\n  this.proc = null\n}\n\nSpawn.prototype.endAll = function () {\n  if (this.proc)\n    this.proc.kill('SIGKILL')\n  this.parser.abort('test unfinished')\n  this.cb()\n}\n\nSpawn.prototype.main = function (cb) {\n  this.cb = cb\n  this.setTimeout(this.options.timeout)\n  var options = Object.keys(this.options).reduce(function (o, k) {\n    o[k] = this.options[k]\n    return o\n  }.bind(this), {\n    cwd: this.cwd,\n    env: this.env,\n    stdio: this.stdio\n  })\n  try {\n    var proc = this.proc = spawn(this.command, this.args, options)\n    proc.stdout.pipe(this.parser)\n    proc.on('close', this.onprocclose.bind(this))\n    proc.on('error', this.threw.bind(this))\n  } catch (er) {\n    this.threw(er)\n  }\n}\n\nSpawn.prototype.threw = function (er, extra, proxy) {\n  extra = Base.prototype.threw.call(this, er, extra, proxy)\n  extra = cleanYamlObject(extra)\n  // unhook entirely\n  this.parser.abort(er.message, extra)\n  if (this.proc) {\n    this.proc.stdout.removeAllListeners('data')\n    this.proc.stdout.removeAllListeners('end')\n    this.proc.removeAllListeners('close')\n    this.proc.kill('SIGKILL')\n  }\n  this.cb()\n}\n\nSpawn.prototype.onprocclose = function (code, signal) {\n  this.debug('SPAWN close %j %s', code, signal)\n  this.options.exitCode = code\n  if (signal)\n    this.options.signal = signal\n  this.results = this.results || {}\n\n  // spawn closing with no tests is treated as a skip.\n  if (this.results.plan && this.results.plan.skipAll && !code && !signal)\n    this.options.skip = this.results.plan.skipReason || true\n\n  if (code || signal) {\n    this.results.ok = false\n    this.parser.ok = false\n  }\n  return this.cb()\n}\n\nSpawn.prototype.timeout = function (extra) {\n  if (this.proc)\n    this.proc.kill('SIGTERM')\n  var t = setTimeout(function () {\n    if (!this.options.signal && this.options.exitCode === undefined) {\n      Base.prototype.timeout.call(this, extra)\n      this.proc.kill('SIGKILL')\n    }\n  }.bind(this), 1000)\n  if (t.unref)\n    t.unref()\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/stdin.js":"var Base = require('./base.js')\nvar util = require('util')\nvar ownOr = require('own-or')\nvar domain = require('domain')\n\nutil.inherits(Stdin, Base)\n\nmodule.exports = Stdin\n\nfunction Stdin (options) {\n  options = options || {}\n  if (!(this instanceof Stdin))\n    return new Stdin(options)\n\n  options.name = ownOr(options, 'name', '/dev/stdin')\n  Base.call(this, options)\n\n  // This has to be here for node 0.10's wonky streams\n  this.stream = ownOr(options, 'tapStream', process.stdin)\n  this.stream.pause()\n}\n\nStdin.prototype.main = function (cb) {\n  this.domain.add(this.stream)\n  this.setTimeout(this.options.timeout)\n  this.stream.pipe(this.parser)\n  this.stream.resume()\n  this.once('end', cb)\n}\n\nStdin.prototype.threw = function (er, extra, proxy) {\n  extra = Base.prototype.threw.call(this, er, extra, proxy)\n  this.options = extra\n  this.parser.abort(er.message, extra)\n  this.parser.end()\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/point.js":"module.exports = TestPoint\n\nvar path = require('path')\nvar binpath = path.resolve(__dirname, '../bin')\nvar util = require('util')\nvar diags = require('./diags.js')\n\nfunction TestPoint (ok, message, extra) {\n  if (typeof ok !== 'boolean')\n    throw new TypeError('ok must be boolean')\n\n  if (!(this instanceof TestPoint))\n    return new TestPoint(ok, message, extra)\n\n  this.ok = ok ? 'ok ' : 'not ok '\n  this.message = tpMessage(message, extra)\n}\n\nfunction tpMessage (message, extra) {\n  message = message + ''\n  if (message)\n    message = ' - ' + message\n  message = message.replace(/[\\n\\r]/g, ' ').replace(/\\t/g, '  ')\n  extra = extra || {}\n\n  if (extra.skip) {\n    message += ' # SKIP'\n    if (typeof extra.skip === 'string')\n      message += ' ' + extra.skip\n  } else if (extra.todo) {\n    message += ' # TODO'\n    if (typeof extra.todo === 'string')\n      message += ' ' + extra.todo\n  } else if (extra.time)\n    message += ' # time=' + extra.time + 'ms'\n\n  var diagYaml = extra.diagnostic ? diags(extra) : ''\n  message += diagYaml\n\n  if (extra.tapChildBuffer || extra.tapChildBuffer === '') {\n    if (!diagYaml)\n      message += ' '\n    message += '{\\n' + extra.tapChildBuffer.trimRight() + '\\n}\\n'\n  }\n\n  message += '\\n'\n  return message\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/diags.js":"module.exports = diags\n\nvar objToYaml = require('./obj-to-yaml.js')\n\nfunction diags (extra) {\n  var y = objToYaml(extra)\n  if (y)\n    y = '\\n' + y\n\n  return y\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/obj-to-yaml.js":"module.exports = objToYaml\n\nvar cleanYamlObject = require('./clean-yaml-object.js')\nvar yaml = require('js-yaml')\n\nfunction objToYaml (obj) {\n  obj = cleanYamlObject(obj)\n  var y = ''\n  if (obj && typeof obj === 'object' && Object.keys(obj).length) {\n    y = yaml.safeDump(obj).split('\\n').map(function (l) {\n      return l.trim() ? '  ' + l : l.trim()\n    }).join('\\n')\n    y = '  ---\\n' + y + '  ...\\n'\n  }\n\n  return y\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/parse-test-args.js":"function typeOf (arg) {\n  var t = typeof arg\n  switch (t) {\n    case 'object':\n      return arg ? 'object' : 'null'\n    default:\n      return t\n  }\n}\n\nmodule.exports = function (name_, extra_, cb_, defaultName) {\n  var name\n  var extra\n  var cb\n\n  // this only works if it's literally the 4th argument.  it's mostly\n  // used internally.\n  defaultName = defaultName || '(unnamed test)'\n\n  for (var i = 0; i < 3 && i < arguments.length; i++) {\n    var arg = arguments[i]\n    var type = typeOf(arg)\n    if (name === undefined && (type === 'string' || type === 'number'))\n      name = '' + arg\n    else if (type === 'object') {\n      extra = arg\n      if (name === undefined)\n        name = null\n    } else if (type === 'function') {\n      if (extra === undefined)\n        extra = {}\n      if (name === undefined)\n        name = null\n      cb = arg\n    } else if (arg === false) {\n      // it's handy while developing to put a ! in front of a\n      // function to temporarily make a test TODO\n      continue\n    } else if (type !== 'undefined')\n      throw new TypeError('unknown argument passed to parseTestArgs: ' + type)\n  }\n\n  if (!extra)\n    extra = {}\n\n  if (!cb)\n    extra.todo = true\n\n  if (!name && extra.name)\n    name = extra.name\n\n  if (!name && cb && cb.name)\n    name = cb.name\n\n  name = name || defaultName\n  extra.name = name\n  extra.cb = cb || todoCb\n  return extra\n}\n\n/* istanbul ignore next */\nfunction todoCb () {\n  throw new Error('callback called for TODO test')\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/asserts.js":"var synonyms = require('./synonyms.js')\nvar deeper = require('deeper') // strict\nvar shallower = require('only-shallow') // in touch with its feelings\nvar tmatch = require('tmatch') // ok with partial estimates\nvar extraFromError = require('./extra-from-error.js')\n\n// Load Buffer the old way for browserify's sake\nvar Buffer = require('buffer').Buffer // eslint-disable-line\n\n// this is actually the \"working half\" of the Test class.\n// each method figures out if it's a pass or fail, and decorates\n// the extra bit, and then calls either pass() or fail() or some\n// other assert method.\n//\n// typically, a plugin would do this on a specific instance, eg on\n// the root test harness instance.  but we do this here to add some\n// useful prototype methods.\n\nexports.decorate = decorate\n\nfunction decorate (t) {\n  t.addAssert('ok', 1, function (obj, message, extra) {\n    message = message || 'expect truthy value'\n    if (obj) {\n      return this.pass(message, extra)\n    }\n\n    return this.fail(message, extra)\n  })\n\n  t.addAssert('notOk', 1, function (obj, message, extra) {\n    message = message || 'expect falsey value'\n    return this.ok(!obj, message, extra)\n  })\n\n  t.addAssert('error', 1, function (er, message, extra) {\n    if (!er) {\n      return this.pass(message || 'should not error', extra)\n    }\n\n    if (!(er instanceof Error)) {\n      extra.found = er\n      return this.fail(message || 'non-Error error encountered', extra)\n    }\n\n    message = message || er.message\n    extra.found = er\n    return this.fail(message, extra)\n  })\n\n  t.addAssert('equal', 2, function (f, w, m, e) {\n    m = m || 'should be equal'\n    if (f === w) {\n      return this.pass(m, e)\n    }\n\n    e.found = f\n    e.wanted = w\n    e.compare = '==='\n\n    if (typeof f === 'object' &&\n        typeof w === 'object' &&\n        f &&\n        w &&\n        shallower(f, w)) {\n      e.note = 'Objects never === one another'\n    }\n\n    return this.fail(m, e)\n  })\n\n  t.addAssert('not', 2, function (f, w, m, e) {\n    m = m || 'should not be equal'\n    if (f !== w) {\n      return this.pass(m, e)\n    }\n\n    e.found = f\n    e.doNotWant = w\n    e.compare = '!=='\n\n    return this.fail(m, e)\n  })\n\n  t.addAssert('same', 2, function (f, w, m, e) {\n    m = m || 'should be equivalent'\n    e.found = f\n    e.wanted = w\n    return this.ok(shallower(f, w), m, e)\n  })\n\n  t.addAssert('notSame', 2, function (f, w, m, e) {\n    m = m || 'should not be equivalent'\n    e.found = f\n    e.doNotWant = w\n    return this.notOk(shallower(f, w), m, e)\n  })\n\n  t.addAssert('strictSame', 2, function (f, w, m, e) {\n    m = m || 'should be equivalent strictly'\n    e.found = f\n    e.wanted = w\n    return this.ok(deeper(f, w), m, e)\n  })\n\n  t.addAssert('strictNotSame', 2, function (f, w, m, e) {\n    m = m || 'should be equivalent strictly'\n    e.found = f\n    e.doNotWant = w\n    return this.notOk(deeper(f, w), m, e)\n  })\n\n  t.addAssert('match', 2, function (f, w, m, e) {\n    m = m || 'should match pattern provided'\n    e.found = f\n    e.pattern = w\n    return this.ok(tmatch(f, w), m, e)\n  })\n\n  t.addAssert('notMatch', 2, function (f, w, m, e) {\n    m = m || 'should not match pattern provided'\n    e.found = f\n    e.pattern = w\n    return this.ok(!tmatch(f, w), m, e)\n  })\n\n  t.addAssert('type', 2, function (obj, klass, m, e) {\n    var name = klass\n    if (typeof name === 'function') {\n      name = name.name || '(anonymous constructor)'\n    }\n    m = m || 'type is ' + name\n\n    // simplest case, it literally is the same thing\n    if (obj === klass) {\n      return this.pass(m, e)\n    }\n\n    var type = typeof obj\n    if (!obj && type === 'object') {\n      type = 'null'\n    }\n\n    if (type === 'object' && klass !== 'object') {\n      if (typeof klass === 'function') {\n        e.found = Object.getPrototypeOf(obj).constructor.name\n        e.wanted = name\n        return this.ok(obj instanceof klass, m, e)\n      }\n\n      // check prototype chain for name\n      // at this point, we already know klass is not a function\n      // if the klass specified is an obj in the proto chain, pass\n      // if the name specified is the name of a ctor in the chain, pass\n      var p = obj\n      do {\n        var ctor = p.constructor && p.constructor.name\n        if (p === klass || ctor === name) {\n          return this.pass(m, e)\n        }\n        p = Object.getPrototypeOf(p)\n      } while (p)\n    }\n\n    return this.equal(type, name, m, e)\n  })\n\n  t.addAssert('throws', 4, function (fn_, wanted_, m_, e_, m, e__) {\n    var fn, wanted, e\n    for (var i = 0; i < arguments.length - 1; i++) {\n      var arg = arguments[i]\n      if (typeof arg === 'function') {\n        if (arg === Error || arg.prototype instanceof Error) {\n          wanted = arg\n        } else if (!fn) {\n          fn = arg\n        }\n      } else if (typeof arg === 'string' && arg) {\n        m = arg\n      } else if (typeof arg === 'object') {\n        if (!wanted) {\n          wanted = arg\n        } else {\n          e = arg\n        }\n      }\n    }\n\n    // Copy local properties of the 'extra' object, like 'skip' etc\n    Object.keys(e__).forEach(function (i) {\n      e[i] = e__[i]\n    })\n\n    if (!m) {\n      m = fn && fn.name || 'expected to throw'\n    }\n\n    if (wanted) {\n      if (wanted instanceof Error) {\n        var w = {\n          message: wanted.message\n        }\n        if (wanted.name) {\n          w.name = wanted.name\n        }\n\n        // intentionally copying non-local properties, since this\n        // is an Error object, and those are funky.\n        for (i in wanted) {\n          w[i] = wanted[i]\n        }\n        wanted = w\n\n        m += ': ' + (wanted.name || 'Error') + ' ' + wanted.message\n        e = e || {}\n        if (e !== wanted) {\n          e.wanted = wanted\n        }\n      }\n    }\n\n    if (typeof fn !== 'function') {\n      e = e || {}\n      e.todo = true\n      return this.pass(m, e)\n    }\n\n    try {\n      fn()\n      return this.fail(m, e)\n    } catch (er) {\n      // 'name' is a getter.\n      if (er.name) {\n        er.name = er.name + ''\n      }\n\n      if (wanted) {\n        if (Object.prototype.toString.call(wanted) === '[object RegExp]') {\n          return this.match(er.message, wanted, m, e)\n        }\n        return this.has(er, wanted, m, e)\n      } else {\n        return this.pass(m, e)\n      }\n    }\n  })\n\n  t.addAssert('doesNotThrow', 1, function (fn, m, e) {\n    if (typeof fn === 'string') {\n      var x = fn\n      fn = m\n      m = x\n    }\n\n    if (!m) {\n      m = fn && fn.name || 'expected to not throw'\n    }\n\n    if (typeof fn !== 'function') {\n      e.todo = true\n      return this.pass(m, e)\n    }\n\n    try {\n      fn()\n      return this.pass(m, e)\n    } catch (er) {\n      return this.fail(m, extraFromError(er, e))\n    }\n  })\n\n  // synonyms are helpful.\n  Object.keys(synonyms).forEach(function (c) {\n    if (t[c]) {\n      synonyms[c].forEach(function (s) {\n        Object.defineProperty(t, s, {\n          value: t[c],\n          enumerable: false,\n          configurable: true,\n          writable: true\n        })\n      })\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/synonyms.js":"// A list of all the synonyms of assert methods.\n// In addition to these, multi-word camelCase are also synonymized to\n// all lowercase and snake_case\nmodule.exports = multiword({\n  ok: ['true', 'assert'],\n  notOk: ['false', 'assertNot'],\n\n  error: ['ifError', 'ifErr'],\n  throws: ['throw'],\n  doesNotThrow: ['notThrow'],\n\n  // exactly the same.  ===\n  equal: [\n    'equals', 'isEqual', 'is', 'strictEqual', 'strictEquals', 'strictIs',\n    'isStrict', 'isStrictly'\n  ],\n\n  // not equal.  !==\n  not: [\n    'inequal', 'notEqual', 'notEquals', 'notStrictEqual', 'notStrictEquals',\n    'isNotEqual', 'isNot', 'doesNotEqual', 'isInequal'\n  ],\n\n  // deep equivalence.  == for scalars\n  same: [\n    'equivalent', 'looseEqual', 'looseEquals', 'deepEqual',\n    'deepEquals', 'isLoose', 'looseIs', 'isEquivalent'\n  ],\n\n  // deep inequivalence. != for scalars\n  notSame: [\n    'inequivalent', 'looseInequal', 'notDeep', 'deepInequal',\n    'notLoose', 'looseNot', 'notEquivalent', 'isNotDeepEqual',\n    'isNotDeeply', 'notDeepEqual', 'isInequivalent',\n    'isNotEquivalent'\n  ],\n\n  // deep equivalence, === for scalars\n  strictSame: [\n    'strictEquivalent', 'strictDeepEqual', 'sameStrict', 'deepIs',\n    'isDeeply', 'isDeep', 'strictDeepEquals'\n  ],\n\n  // deep inequivalence, !== for scalars\n  strictNotSame: [\n    'strictInequivalent', 'strictDeepInequal', 'notSameStrict', 'deepNot',\n    'notDeeply', 'strictDeepInequals', 'notStrictSame'\n  ],\n\n  // found has the fields in wanted, string matches regexp\n  match: [\n    'has', 'hasFields', 'matches', 'similar', 'like', 'isLike',\n    'includes', 'include', 'isSimilar', 'contains'\n  ],\n\n  notMatch: [\n    'dissimilar', 'unsimilar', 'notSimilar', 'unlike', 'isUnlike',\n    'notLike', 'isNotLike', 'doesNotHave', 'isNotSimilar', 'isDissimilar'\n  ],\n\n  type: [\n    'isa', 'isA'\n  ]\n})\n\nfunction multiword (obj) {\n  Object.keys(obj).forEach(function (i) {\n    var list = obj[i]\n    var res = [ multiword_(i) ].concat(list.map(multiword_))\n    res = res.reduce(function (set, i) {\n      set.push.apply(set, i)\n      return set\n    }, [])\n    obj[i] = res\n  })\n  return obj\n}\n\nfunction multiword_ (str) {\n  var res = [ str ]\n  if (str.match(/[A-Z]/)) {\n    res.push(str.toLowerCase())\n    res.push(str.replace(/[A-Z]/g, function ($0) {\n      return '_' + $0.toLowerCase()\n    }))\n  }\n  return res\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/lib/mocha.js":"exports.it = exports.specify = it\nexports.context = exports.describe = describe\nexports.before = before\nexports.after = after\nexports.beforeEach = beforeEach\nexports.afterEach = afterEach\n\nexports.global = function () {\n  Object.keys(exports).forEach(function (g) {\n    global[g] = exports[g]\n  })\n}\n\nvar t = require('./tap.js')\nt.jobs = 1\nvar tapStack = [ t ]\nvar level = 0\nvar suiteStack = []\n\nfunction describe (name, fn) {\n  new Suite(name, fn)\n}\n\nfunction Suite (name, fn) {\n  this.parent = suiteStack[ suiteStack.length - 1 ]\n  if (typeof name === 'function')\n    fn = name, name = null\n  if (fn && fn.name && !name)\n    name = fn.name\n  this.todo = !fn\n  this.fn = fn\n  this.name = name\n  this.after = []\n  this.test = null\n\n  this.run()\n}\n\nSuite.prototype.run = function () {\n  var t = tapStack[ tapStack.length - 1 ]\n  t.test(this.name, { todo: this.todo }, function (tt) {\n    this.test = tt\n    tapStack.push(tt)\n    suiteStack.push(this)\n    var ret = this.fn()\n    this.runAfter()\n    suiteStack.pop()\n    return ret\n  }.bind(this))\n}\n\nSuite.prototype.runAfter = function () {\n  this.after.forEach(function (namefn) {\n    var name = namefn[0]\n    var fn = namefn[1]\n    before(name, fn)\n  })\n  do {\n    var t = tapStack.pop()\n  } while (t && t !== this.test)\n  if (this.test && !this.test.results)\n    t.end()\n}\n\nfunction before (name, fn) {\n  if (typeof name === 'function')\n    fn = name, name = null\n  if (fn && fn.name && !name)\n    name = fn.name\n  var todo = !fn\n  var suite = suiteStack[ suiteStack.length - 1 ]\n  var t = tapStack[ tapStack.length - 1 ]\n  if (!name)\n    name = ''\n  t.test(name, { todo: todo, silent: true }, function (tt) {\n    var ret = fn.call(suite, done(tt))\n    if (!ret && fn.length === 0)\n      tt.end()\n    else\n      return ret\n  })\n\n  function done (tt) { return function (er) {\n    if (er)\n      tt.threw(er)\n    else\n      tt.end()\n  }}\n}\n\nfunction it (name, fn) {\n  if (typeof name === 'function')\n    fn = name, name = null\n  if (fn && fn.name && !name)\n    name = fn.name\n  var todo = !fn\n  var suite = suiteStack[ suiteStack.length - 1 ]\n  var t = tapStack[ tapStack.length - 1 ]\n  if (!name)\n    name = ''\n  t.test(name, { todo: todo, tapMochaTest: true }, function (tt) {\n    var ret = fn.call(tt, done(tt))\n    if (ret && ret.then)\n      return ret\n    else if (fn.length === 0)\n      tt.end()\n  })\n\n  function done (tt) { return function (er) {\n    if (er)\n      tt.threw(er)\n    else\n      tt.end()\n  }}\n}\n\nfunction after (name, fn) {\n  var suite = suiteStack[ suiteStack.length - 1 ]\n  if (!suite)\n    throw new Error('cannot call \"after\" outside of describe()')\n  if (fn)\n    suite.after.push([name, fn])\n  else\n    suite.after.push([name])\n}\n\nfunction moment (when, fn) {\n  var t = tapStack[ tapStack.length - 1 ]\n  t[when](function (cb) {\n    if (!this.options.tapMochaTest)\n      return cb()\n    var suite = suiteStack[ suiteStack.length - 1 ]\n    var ret = fn.call(this, cb)\n    if (ret && ret.then)\n      return ret\n    else if (fn.length === 0)\n      return cb()\n  })\n}\n\nfunction beforeEach (fn) {\n  moment('beforeEach', fn)\n}\n\nfunction afterEach (fn) {\n  moment('afterEach', fn)\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/bin/mochatap.js":"#!/usr/bin/env node\nvar tap = require('../lib/tap.js')\nvar args = process.argv.slice(2)\n\nif (args.length === 1) {\n  var path = require('path')\n  var file = path.resolve(args[0])\n  tap.mochaGlobals()\n  require(file)\n} else {\n  for (var i = 0; i < args.length; i++) {\n    tap.spawn(process.execPath, [__filename, args[i]])\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap/bin/run.js":"#!/usr/bin/env node\n\nvar node = process.execPath\nvar fs = require('fs')\nvar spawn = require('child_process').spawn\nvar fg = require('foreground-child')\nvar opener = require('opener')\nvar colorSupport = require('color-support')\nvar nycBin = require.resolve('nyc/bin/nyc.js')\nvar glob = require('glob')\nvar isexe = require('isexe')\nvar osHomedir = require('os-homedir')\nvar yaml = require('js-yaml')\nvar path = require('path')\nvar exists = require('fs-exists-cached').sync\nvar os = require('os');\n\nvar coverageServiceTest = process.env.COVERAGE_SERVICE_TEST === 'true'\n\n// NYC will not wrap a module in node_modules.\n// So, we need to tell the child proc when it's been added.\nif (process.env._TAP_COVERAGE_ === '1')\n  global.__coverage__ = global.__coverage__ || {}\n\n// console.error(process.argv.join(' '))\n// console.error('CST=%j', process.env.COVERAGE_SERVICE_TEST)\n// console.error('CRT=%j', process.env.COVERALLS_REPO_TOKEN)\nif (coverageServiceTest)\n  console.log('COVERAGE_SERVICE_TEST')\n\n// Add new coverage services here.\n// it'll check for the environ named and pipe appropriately.\n//\n// Currently only Coveralls is supported, but the infrastructure\n// is left in place in case some noble soul fixes the codecov\n// module in the future.  See https://github.com/tapjs/node-tap/issues/270\nvar coverageServices = [\n  {\n    env: 'COVERALLS_REPO_TOKEN',\n    bin: require.resolve('coveralls/bin/coveralls.js'),\n    name: 'Coveralls'\n  }\n]\n\nmain()\n\nfunction main () {\n  var args = process.argv.slice(2)\n\n  if (!args.length && process.stdin.isTTY) {\n    console.error(usage())\n    process.exit(1)\n  }\n\n  // set default args\n  var defaults = constructDefaultArgs()\n\n  // parse dotfile\n  var rcFile = process.env.TAP_RCFILE || (osHomedir() + '/.taprc')\n  var rcOptions = parseRcFile(rcFile)\n\n  // supplement defaults with parsed rc options\n  if (rcOptions)\n    Object.keys(rcOptions).forEach(function (k) {\n      defaults[k] = rcOptions[k]\n    })\n\n  defaults.rcFile = rcFile\n\n  // parse args\n  var options = parseArgs(args, defaults)\n\n  if (!options)\n    return\n\n  process.stdout.on('error', function (er) {\n    if (er.code === 'EPIPE')\n      process.exit()\n    else\n      throw er\n  })\n\n  options.files = globFiles(options.files)\n\n  if ((options.coverageReport || options.checkCoverage) &&\n      options.files.length === 0)\n    return runCoverageReport(options)\n\n  if (options.files.length === 0) {\n    console.error('Reading TAP data from stdin (use \"-\" argument to suppress)')\n    options.files.push('-')\n  }\n\n  if (options.files.length === 1 && options.files[0] === '-') {\n    if (options.coverage)\n      console.error('Coverage disabled because stdin cannot be instrumented')\n    stdinOnly(options)\n    return\n  }\n\n  // By definition, the next block cannot be covered, because\n  // they are only relevant when coverage is turned off.\n\n  /* istanbul ignore if */\n  if (options.coverage && !global.__coverage__)\n    return respawnWithCoverage(options)\n\n  setupTapEnv(options)\n\n  runTests(options)\n}\n\nfunction constructDefaultArgs () {\n  var defaultTimeout = 30\n  if (global.__coverage__)\n    defaultTimeout = 240\n\n  var defaultArgs = {\n    nodeArgs: [],\n    nycArgs: [],\n    testArgs: [],\n    timeout: +process.env.TAP_TIMEOUT || defaultTimeout,\n    color: !!colorSupport.level,\n    reporter: null,\n    files: [],\n    bail: false,\n    saveFile: null,\n    pipeToService: false,\n    coverageReport: null,\n    browser: true,\n    coverage: undefined,\n    checkCoverage: false,\n    branches: 0,\n    functions: 0,\n    lines: 0,\n    statements: 0,\n    jobs: 1,\n    outputFile: null\n  }\n\n  if (process.env.TAP_COLORS !== undefined)\n    defaultArgs.color = !!(+process.env.TAP_COLORS)\n\n  return defaultArgs\n}\n\nfunction parseArgs (args, defaults) {\n  var options = defaults || {}\n\n  var singleFlags = {\n    b: 'bail',\n    B: 'no-bail',\n    c: 'color',\n    C: 'no-color',\n    T: 'no-timeout',\n    J: 'jobs-auto',\n    h: 'help',\n    '?': 'help',\n    v: 'version'\n  }\n\n  var singleOpts = {\n    j: 'jobs',\n    R: 'reporter',\n    t: 'timeout',\n    s: 'save',\n    o: 'output-file'\n  }\n\n  // If we're running under Travis-CI with a Coveralls.io token,\n  // then it's a safe bet that we ought to output coverage.\n  for (var i = 0; i < coverageServices.length && !options.pipeToService; i++) {\n    if (process.env[coverageServices[i].env])\n      options.pipeToService = true\n  }\n\n  var defaultCoverage = options.pipeToService\n  var dumpConfig = false\n\n  for (i = 0; i < args.length; i++) {\n    var arg = args[i]\n    if (arg.charAt(0) !== '-' || arg === '-') {\n      options.files.push(arg)\n      continue\n    }\n\n    // short-flags\n    if (arg.charAt(1) !== '-' && arg !== '-gc') {\n      var expand = []\n      for (var f = 1; f < arg.length; f++) {\n        var fc = arg.charAt(f)\n        var sf = singleFlags[fc]\n        var so = singleOpts[fc]\n        if (sf)\n          expand.push('--' + sf)\n        else if (so) {\n          var soval = arg.slice(f + 1)\n          if (soval.charAt(0) !== '=') {\n            soval = '=' + soval\n          }\n          expand.push('--' + so + soval)\n          f = arg.length\n        } else if (arg !== '-' + fc)\n          expand.push('-' + fc)\n      }\n      if (expand.length) {\n        args.splice.apply(args, [i, 1].concat(expand))\n        i--\n        continue\n      }\n    }\n\n    var key = arg\n    var val = null\n    if (key.match(/^--/) && arg.indexOf('=') !== -1) {\n      var kv = arg.split('=')\n      key = kv.shift()\n      val = kv.join('=')\n    }\n\n    switch (key) {\n      case '--help':\n        console.log(usage())\n        return null\n\n      case '--dump-config':\n        dumpConfig = true\n        continue\n\n      case '--nyc-help':\n        nycHelp()\n        return null\n\n      case '--nyc-version':\n        nycVersion()\n        return null\n\n      case '--version':\n        console.log(require('../package.json').version)\n        return null\n\n      case '--jobs':\n        val = val || args[++i]\n        options.jobs = +val\n        continue\n\n      case '--jobs-auto':\n        val = os.cpus().length;\n        options.jobs = +val\n        continue\n\n      case '--coverage-report':\n        options.coverageReport = val || args[++i]\n        if (options.coverageReport === 'html')\n          options.coverageReport = 'lcov'\n        defaultCoverage = true\n        continue\n\n      case '--no-browser':\n        options.browser = false\n        continue\n\n      case '--no-coverage-report':\n        options.coverageReport = false\n        continue\n\n      case '--no-cov': case '--no-coverage':\n        options.coverage = false\n        continue\n\n      case '--cov': case '--coverage':\n        options.coverage = true\n        continue\n\n      case '--save':\n        val = val || args[++i]\n        options.saveFile = val\n        continue\n\n      case '--reporter':\n        val = val || args[++i]\n        options.reporter = val\n        continue\n\n      case '--gc': case '-gc': case '--expose-gc':\n        options.nodeArgs.push('--expose-gc')\n        continue\n\n      case '--strict':\n        options.nodeArgs.push('--use_strict')\n        continue\n\n      case '--debug':\n        options.nodeArgs.push('--debug')\n        continue\n\n      case '--debug-brk':\n        options.nodeArgs.push('--debug-brk')\n        continue\n\n      case '--harmony':\n        options.nodeArgs.push('--harmony')\n        continue\n\n      case '--node-arg':\n        val = val || args[++i]\n        if (val !== undefined)\n          options.nodeArgs.push(val)\n        continue\n\n      case '--check-coverage':\n        defaultCoverage = true\n        options.checkCoverage = true\n        continue\n\n      case '--test-arg':\n        val = val || args[++i]\n        if (val !== undefined)\n          options.testArgs.push(val)\n        continue\n\n      case '--nyc-arg':\n        val = val || args[++i]\n        if (val !== undefined)\n          options.nycArgs.push(val)\n        continue\n\n      case '--100':\n        defaultCoverage = true\n        options.checkCoverage = true\n        options.branches = 100\n        options.functions = 100\n        options.lines = 100\n        options.statements = 100\n        continue\n\n      case '--branches':\n      case '--functions':\n      case '--lines':\n      case '--statements':\n        defaultCoverage = true\n        val = val || args[++i]\n        options.checkCoverage = true\n        options[key.slice(2)] = val\n        continue\n\n      case '--color':\n        options.color = true\n        continue\n\n      case '--no-color':\n        options.color = false\n        continue\n\n      case '--output-file':\n        val = val || args[++i]\n        if (val !== undefined)\n          options.outputFile = val\n        continue\n\n      case '--no-timeout':\n        options.timeout = 0\n        continue\n\n      case '--timeout':\n        val = val || args[++i]\n        options.timeout = +val\n        continue\n\n      case '--bail':\n        options.bail = true\n        continue\n\n      case '--no-bail':\n        options.bail = false\n        continue\n\n      case '--':\n        options.files = options.files.concat(args.slice(i + 1))\n        i = args.length\n        continue\n\n      default:\n        throw new Error('Unknown argument: ' + arg)\n    }\n  }\n\n  if (options.coverage === undefined)\n    options.coverage = defaultCoverage\n\n  if (process.env.TAP === '1')\n    options.reporter = 'tap'\n\n  // default to tap for non-tty envs\n  if (!options.reporter)\n    options.reporter = options.color ? 'classic' : 'tap'\n\n  if (dumpConfig)\n    return console.log(JSON.stringify(options, null, 2))\n\n  return options\n}\n\n/* istanbul ignore next */\nfunction respawnWithCoverage (options) {\n  // console.error('respawn with coverage')\n  // Re-spawn with coverage\n  var args = [nycBin].concat(\n    '--silent',\n    '--cache=true',\n    options.nycArgs,\n    '--',\n    process.execArgv,\n    process.argv.slice(1)\n  )\n  process.env._TAP_COVERAGE_ = '1'\n  var child = fg(node, args)\n  child.removeAllListeners('close')\n  child.on('close', function (code, signal) {\n    runCoverageReport(options, code, signal)\n  })\n}\n\nfunction pipeToCoverageServices (options, child) {\n  // console.error('pipe to services')\n  var piped = false\n  for (var i = 0; i < coverageServices.length; i++) {\n    // console.error('pipe to service?', coverageServices[i].env)\n    if (process.env[coverageServices[i].env]) {\n      pipeToCoverageService(coverageServices[i], options, child)\n      piped = true\n    }\n  }\n\n  /* istanbul ignore if */\n  if (!piped)\n    throw new Error('unknown service, internal error')\n}\n\nfunction pipeToCoverageService (service, options, child) {\n  // console.error('pipe to service yes', service.env)\n  var bin = service.bin\n\n  if (coverageServiceTest) {\n    // console.error('use fakey test bin')\n    // test scaffolding.\n    // don't actually send stuff to the service\n    bin = require.resolve('../test/fixtures/cat.js')\n    console.log('%s:%s', service.name, process.env[service.env])\n  }\n\n  var ca = spawn(node, [bin], {\n    stdio: [ 'pipe', 1, 2 ]\n  })\n\n  child.stdout.pipe(ca.stdin)\n\n  ca.on('close', function (code, signal) {\n    if (signal)\n      process.kill(process.pid, signal)\n    else if (code)\n      console.log('Error piping coverage to ' + service.name)\n    else\n      console.log('Successfully piped to ' + service.name)\n  })\n}\n\nfunction runCoverageReport (options, code, signal) {\n  if (options.checkCoverage)\n    runCoverageCheck(options, code, signal)\n  else\n    runCoverageReportOnly(options, code, signal)\n}\n\nfunction runCoverageReportOnly (options, code, signal) {\n  if (options.coverageReport === false)\n    return close(code, signal)\n\n  if (!options.coverageReport) {\n    if (options.pipeToService || coverageServiceTest)\n      options.coverageReport = 'text-lcov'\n    else\n      options.coverageReport = 'text'\n  }\n\n  var args = [nycBin, 'report', '--reporter', options.coverageReport]\n  // console.error('run coverage report', args)\n\n  var child\n  // automatically hook into coveralls\n  if (options.coverageReport === 'text-lcov' && options.pipeToService) {\n    // console.error('pipeToService')\n    child = spawn(node, args, { stdio: [ 0, 'pipe', 2 ] })\n    pipeToCoverageServices(options, child)\n  } else {\n    // otherwise just run the reporter\n    child = fg(node, args)\n    if (options.coverageReport === 'lcov' && options.browser)\n      child.on('exit', function () {\n        opener('coverage/lcov-report/index.html')\n      })\n  }\n\n  if (code || signal) {\n    child.removeAllListeners('close')\n    child.on('close', close)\n  }\n\n  function close (c, s) {\n    if (signal || s) {\n      setTimeout(function () {}, 200)\n      return process.kill(process.pid, signal || s)\n    }\n    if (code || c)\n      return process.exit(code || c)\n  }\n}\n\nfunction coverageCheckArgs (options) {\n  var args = []\n  if (options.branches)\n    args.push('--branches', options.branches)\n  if (options.functions)\n    args.push('--functions', options.functions)\n  if (options.lines)\n    args.push('--lines', options.lines)\n  if (options.statements)\n    args.push('--statements', options.statements)\n\n  return args\n}\n\nfunction runCoverageCheck (options, code, signal) {\n  var args = [nycBin, 'check-coverage'].concat(coverageCheckArgs(options))\n\n  var child = fg(node, args)\n  child.removeAllListeners('close')\n  child.on('close', function (c, s) {\n    runCoverageReportOnly(options, code || c, signal || s)\n  })\n}\n\nfunction usage () {\n  return fs.readFileSync(__dirname + '/usage.txt', 'utf8')\n    .split('@@REPORTERS@@')\n    .join(getReporters())\n}\n\nfunction nycHelp () {\n  fg(node, [nycBin, '--help'])\n}\n\nfunction nycVersion () {\n  console.log(require('nyc/package.json').version)\n}\n\nfunction getReporters () {\n  var types = require('tap-mocha-reporter').types\n  types = types.reduce(function (str, t) {\n    var ll = str.split('\\n').pop().length + t.length\n    if (ll < 40)\n      return str + ' ' + t\n    else\n      return str + '\\n' + t\n  }, '').trim()\n  var ind = '                              '\n  return ind + types.split('\\n').join('\\n' + ind)\n}\n\nfunction setupTapEnv (options) {\n  process.env.TAP_TIMEOUT = options.timeout\n  if (options.color)\n    process.env.TAP_COLORS = 1\n  else\n    process.env.TAP_COLORS = 0\n\n  if (options.bail)\n    process.env.TAP_BAIL = '1'\n}\n\nfunction globFiles (files) {\n  return files.reduce(function (acc, f) {\n    if (f === '-') {\n      acc.push(f)\n      return acc\n    }\n\n    // glob claims patterns MUST not include any '\\'s\n    if (!/\\\\/.test(f))\n      f = glob.sync(f) || f\n\n    return acc.concat(f)\n  }, [])\n}\n\nfunction makeReporter (options) {\n  var TMR = require('tap-mocha-reporter')\n  return new TMR(options.reporter)\n}\n\nfunction stdinOnly (options) {\n  // if we didn't specify any files, then just passthrough\n  // to the reporter, so we don't get '/dev/stdin' in the suite list.\n  // We have to pause() before piping to switch streams2 into old-mode\n  process.stdin.pause()\n  var reporter = makeReporter(options)\n  process.stdin.pipe(reporter)\n  process.stdin.resume()\n}\n\nfunction readSaveFile (options) {\n  if (options.saveFile)\n    try {\n      return fs.readFileSync(options.saveFile, 'utf8').trim().split('\\n')\n    } catch (er) {}\n\n  return null\n}\n\nfunction saveFails (options, tap) {\n  if (!options.saveFile)\n    return\n\n  var fails = []\n  var successes = []\n  tap.on('result', function (res) {\n    // we will continue to re-run todo tests, even though they're\n    // not technically \"failures\".\n    if (!res.ok && !res.extra.skip)\n      fails.push(res.extra.file)\n    else\n      successes.push(res.extra.file)\n  })\n\n  tap.on('bailout', function (reason) {\n    // add any pending test files to the fails list.\n    fails.push.apply(fails, options.files.filter(function (file) {\n      return successes.indexOf(file) === -1\n    }))\n    save()\n  })\n\n  tap.on('end', save)\n\n  function save () {\n    fails = fails.reduce(function (set, f) {\n      if (set.indexOf(f) === -1)\n        set.push(f)\n      return set\n    }, [])\n\n    if (!fails.length)\n      try {\n        fs.unlinkSync(options.saveFile)\n      } catch (er) {}\n    else\n      try {\n        fs.writeFileSync(options.saveFile, fails.join('\\n') + '\\n')\n      } catch (er) {}\n  }\n}\n\nfunction filterFiles (files, saved, parallelOk) {\n  return files.filter(function (file) {\n    if (path.basename(file) === 'tap-parallel-ok')\n      parallelOk[path.resolve(path.dirname(file))] = true\n    else if (path.basename(file) === 'tap-parallel-not-ok')\n      parallelOk[path.resolve(path.dirname(file))] = false\n    else\n      return saved === null || saved.indexOf(file) !== -1\n  })\n}\n\nfunction isParallelOk (parallelOk, file) {\n  var dir = path.resolve(path.dirname(file))\n\n  if (dir in parallelOk)\n    return parallelOk[dir]\n\n  if (exists(dir + '/tap-parallel-ok'))\n    return parallelOk[dir] = true\n\n  if (exists(dir + '/tap-parallel-not-ok'))\n    return parallelOk[dir] = false\n\n  if (dir.length >= process.cwd().length)\n    return isParallelOk(parallelOk, dir)\n}\n\nfunction runAllFiles (options, saved, tap) {\n  var doStdin = false\n  var parallelOk = Object.create(null)\n\n  options.files = filterFiles(options.files, saved, parallelOk)\n\n  for (var i = 0; i < options.files.length; i++) {\n    var opt = {}\n    var file = options.files[i]\n\n    // Pick up stdin after all the other files are handled.\n    if (file === '-') {\n      doStdin = true\n      continue\n    }\n\n    var st = fs.statSync(options.files[i])\n    if (options.timeout)\n      opt.timeout = options.timeout * 1000\n\n    opt.file = file\n    if (options.jobs > 1)\n      opt.buffered = isParallelOk(parallelOk, file) !== false\n\n    if (file.match(/\\.js$/)) {\n      var args = options.nodeArgs.concat(file).concat(options.testArgs)\n      tap.spawn(node, args, opt, file)\n    } else if (st.isDirectory()) {\n      var dir = filterFiles(fs.readdirSync(file).map(function (f) {\n        return file + '/' + f\n      }), saved, parallelOk)\n      options.files.push.apply(options.files, dir)\n    } else if (isexe.sync(options.files[i]))\n      tap.spawn(options.files[i], options.testArgs, opt, file)\n  }\n\n  if (doStdin)\n    tap.stdin()\n}\n\nfunction runTests (options) {\n  var saved = readSaveFile(options)\n\n  // At this point, we know we need to use the tap root,\n  // because there are 1 or more files to spawn.\n  var tap = require('../lib/tap.js')\n\n  tap.jobs = options.jobs\n  tap.patchProcess()\n\n  // if not -Rtap, then output what the user wants.\n  // otherwise just dump to stdout\n  tap.pipe(options.reporter === 'tap' ? process.stdout: makeReporter(options))\n\n  // need to replay the first version line, because the previous\n  // line will have flushed it out to stdout or the reporter already.\n  if (options.outputFile !== null)\n    tap.pipe(fs.createWriteStream(options.outputFile)).write('TAP version 13\\n')\n\n  saveFails(options, tap)\n\n  runAllFiles(options, saved, tap)\n\n  tap.end()\n}\n\nfunction parseRcFile (path) {\n  try {\n    var contents = fs.readFileSync(path, 'utf8')\n    return yaml.safeLoad(contents) || {}\n  } catch (er) {\n    // if no dotfile exists, or invalid yaml, fail gracefully\n    return {}\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-tap/node_modules/tap-mocha-reporter/index.js":"#!/usr/bin/env node\n\nmodule.exports = Formatter\n\nvar util = require('util')\nvar reporters = require('./lib/reporters/index.js')\nFormatter.types = Object.keys(reporters).sort()\nvar Writable = require('stream').Writable\nif (!Writable) {\n  try {\n    Writable = require('readable-stream').Writable\n  } catch (er) {\n    throw new Error('Please install \"readable-stream\" to use this module ' +\n                    'with Node.js v0.8 and before')\n  }\n}\n\nvar Runner = require('./lib/runner.js')\nvar Parser = require('tap-parser')\n\nutil.inherits(Formatter, Writable)\n\nvar exitCode\nfunction Formatter (type, options) {\n  if (!(this instanceof Formatter)) {\n    return new Formatter(type, options)\n  }\n  if (!reporters[type]) {\n    console.error('Unknown format type: %s\\n\\n%s', type, avail())\n    type = 'silent'\n  }\n\n  this.writable = true\n\n  // don't actually need a reporter to report the tap we're getting\n  // just parse it so that we exit with the correct code, but otherwise\n  // dump it straight through to stdout.\n  if (type === 'tap') {\n    var p = new Parser()\n    this.write = function (chunk) {\n      process.stdout.write(chunk)\n      return p.write(chunk)\n    }\n    this.end = p.end.bind(p)\n    p.on('complete', function () {\n      if (!p.ok)\n        exitCode = 1\n    })\n    return this\n  }\n\n  var runner = this.runner = new Runner(options)\n  this.reporter = new reporters[type](this.runner, {})\n  Writable.call(this, options)\n\n  runner.on('end', function () {\n    if (!runner.parser.ok)\n      exitCode = 1\n  })\n}\n\nprocess.on('exit', function (code) {\n  if (!code && exitCode)\n    process.exit(exitCode)\n})\n\nFormatter.prototype.write = function () {\n  return this.runner.write.apply(this.runner, arguments)\n}\n\nFormatter.prototype.end = function () {\n  return this.runner.end.apply(this.runner, arguments)\n}\n\nfunction avail () {\n  var types = Formatter.types.reduce(function (str, t) {\n    var ll = str.split('\\n').pop().length + t.length\n    if (ll < 40)\n      return str + ' ' + t\n    else\n      return str + '\\n' + t\n  }, '').trim()\n\n  return 'Available format types:\\n\\n' + types\n}\n\n\nfunction usage (err) {\n  console[err ? 'error' : 'log'](function () {/*\nUsage:\n  tap-mocha-reporter <type>\n\nReads TAP data on stdin, and formats to stdout using the specified\nreporter.  (Note that some reporters write to files instead of stdout.)\n\n%s\n*/}.toString().split('\\n').slice(1, -1).join('\\n'), avail())\n}\n\nif (require.main === module) {\n  var type = process.argv[2]\n  if (!type)\n    return usage()\n\n  process.stdin.pipe(new Formatter(type))\n}\n"}